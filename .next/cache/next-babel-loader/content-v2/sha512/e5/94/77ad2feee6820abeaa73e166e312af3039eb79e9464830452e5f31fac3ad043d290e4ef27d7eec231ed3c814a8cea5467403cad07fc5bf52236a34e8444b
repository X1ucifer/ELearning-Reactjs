{"ast":null,"code":"import Cors from 'cors';\nimport initMiddleware from '@/lib/init-middleware';\nimport bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\nimport isLength from 'validator/lib/isLength';\nimport { users as User, enroled_courses as Enroled_courses, courses as Course } from '@/models/index'; // Initialize the cors middleware\n\nconst cors = initMiddleware( // You can read more about the available options here: https://github.com/expressjs/cors#configuration-options\nCors({\n  // Only allow requests with GET, POST and OPTIONS\n  methods: ['GET', 'POST', 'OPTIONS', 'DELETE', 'PUT']\n}));\nexport default (async (req, res) => {\n  await cors(req, res);\n\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({\n      message: \"No autorization token\"\n    });\n  }\n\n  switch (req.method) {\n    case \"POST\":\n      await handlePostRequest(req, res);\n      break;\n\n    case \"GET\":\n      await handleGetRequest(req, res);\n      break;\n\n    case \"PUT\":\n      await handlePutRequest(req, res);\n      break;\n\n    default:\n      res.status(405).send(`Method ${req.method} not allowed`);\n  }\n});\n\nconst handlePostRequest = async (req, res) => {\n  const {\n    currentPassword,\n    newPassword,\n    newConfirmPassword\n  } = req.body;\n\n  try {\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET); // check email, name, password format\n\n    if (!currentPassword) {\n      return res.status(422).send({\n        message: \"Must be provide current Password!\"\n      });\n    } else if (!isLength(newPassword, {\n      min: 6,\n      max: 12\n    })) {\n      return res.status(422).send({\n        message: \"New Password must be 6-12 characters long!\"\n      });\n    } else if (newPassword != newConfirmPassword) {\n      return res.status(422).json({\n        message: \"Confirm password doesn't matched!\"\n      });\n    }\n\n    const newPasswordHash = await bcrypt.hash(newPassword, 10);\n    const user = await User.findOne({\n      attributes: ['password'],\n      where: {\n        id: userId\n      }\n    });\n    const match = await bcrypt.compare(currentPassword, user.password);\n\n    if (!match) {\n      return res.status(422).send({\n        message: \"Current Password doesn't match!\"\n      });\n    }\n\n    await User.update({\n      password: newPasswordHash\n    }, {\n      where: {\n        id: userId\n      }\n    });\n    res.status(200).json({\n      \"message\": \"Successfully updated the password!\"\n    });\n  } catch (error) {\n    console.error(error);\n    res.status(403).json({\n      message: \"Invalid token\"\n    });\n  }\n};\n\nconst handlePutRequest = async (req, res) => {\n  const {\n    name,\n    designation,\n    location,\n    description\n  } = req.body;\n\n  try {\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET);\n    await User.update({\n      name: name,\n      designation: designation,\n      description: description,\n      location: location\n    }, {\n      where: {\n        id: userId\n      }\n    });\n    res.status(200).json({\n      \"message\": \"Successfully updated the profile!\"\n    });\n  } catch (error) {\n    res.status(403).json({\n      message: \"Invalid token\"\n    });\n  }\n};\n\nconst handleGetRequest = async (req, res) => {\n  try {\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET);\n    const user = await User.findOne({\n      attributes: {\n        exclude: ['password']\n      },\n      where: {\n        id: userId\n      },\n      include: [{\n        model: Enroled_courses,\n        as: 'enroled_courses',\n        attributes: ['courseId']\n      }]\n    });\n\n    if (user) {\n      res.status(200).json(user);\n    } else {\n      res.status(404).send(\"User not found\");\n    }\n  } catch (error) {\n    res.status(403).send(\"Invalid token\");\n  }\n};","map":null,"metadata":{},"sourceType":"module"}