{"ast":null,"code":"import Cors from 'cors';\nimport initMiddleware from '@/lib/init-middleware';\nimport bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\nimport isLength from 'validator/lib/isLength';\nimport { users as User, enroled_courses as Enroled_courses, courses as Course } from '@/models/index'; // Initialize the cors middleware\n\nconst cors = initMiddleware( // You can read more about the available options here: https://github.com/expressjs/cors#configuration-options\nCors({\n  // Only allow requests with GET, POST and OPTIONS\n  methods: ['GET', 'POST', 'OPTIONS', 'DELETE', 'PUT']\n}));\nexport default (async (req, res) => {\n  await cors(req, res);\n\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({\n      message: \"No autorization token\"\n    });\n  }\n\n  switch (req.method) {\n    case \"POST\":\n      await handlePostRequest(req, res);\n      break;\n\n    case \"GET\":\n      await handleGetRequest(req, res);\n      break;\n\n    case \"PUT\":\n      await handlePutRequest(req, res);\n      break;\n\n    default:\n      res.status(405).send(`Method ${req.method} not allowed`);\n  }\n});\n\nconst handlePostRequest = async (req, res) => {\n  const {\n    currentPassword,\n    newPassword,\n    newConfirmPassword\n  } = req.body;\n\n  try {\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET); // check email, name, password format\n\n    if (!currentPassword) {\n      return res.status(422).send({\n        message: \"Must be provide current Password!\"\n      });\n    } else if (!isLength(newPassword, {\n      min: 6,\n      max: 12\n    })) {\n      return res.status(422).send({\n        message: \"New Password must be 6-12 characters long!\"\n      });\n    } else if (newPassword != newConfirmPassword) {\n      return res.status(422).json({\n        message: \"Confirm password doesn't matched!\"\n      });\n    }\n\n    const newPasswordHash = await bcrypt.hash(newPassword, 10);\n    const user = await User.findOne({\n      attributes: ['password'],\n      where: {\n        id: userId\n      }\n    });\n    const match = await bcrypt.compare(currentPassword, user.password);\n\n    if (!match) {\n      return res.status(422).send({\n        message: \"Current Password doesn't match!\"\n      });\n    }\n\n    await User.update({\n      password: newPasswordHash\n    }, {\n      where: {\n        id: userId\n      }\n    });\n    res.status(200).json({\n      \"message\": \"Successfully updated the password!\"\n    });\n  } catch (error) {\n    console.error(error);\n    res.status(403).json({\n      message: \"Invalid token\"\n    });\n  }\n};\n\nconst handlePutRequest = async (req, res) => {\n  const {\n    name,\n    designation,\n    location,\n    description\n  } = req.body;\n\n  try {\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET);\n    await User.update({\n      name: name,\n      designation: designation,\n      description: description,\n      location: location\n    }, {\n      where: {\n        id: userId\n      }\n    });\n    res.status(200).json({\n      \"message\": \"Successfully updated the profile!\"\n    });\n  } catch (error) {\n    res.status(403).json({\n      message: \"Invalid token\"\n    });\n  }\n};\n\nconst handleGetRequest = async (req, res) => {\n  try {\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET);\n    const user = await User.findOne({\n      attributes: {\n        exclude: ['password']\n      },\n      where: {\n        id: userId\n      },\n      include: [{\n        model: Enroled_courses,\n        as: 'enroled_courses',\n        attributes: ['courseId']\n      }]\n    });\n\n    if (user) {\n      res.status(200).json(user);\n    } else {\n      res.status(404).send(\"User not found\");\n    }\n  } catch (error) {\n    res.status(403).send(\"Invalid token\");\n  }\n};","map":{"version":3,"sources":["C:/Users/AJ/Downloads/Spyberrys/Spyberrys/Spyberrys_app/pages/api/v1/auth/account.js"],"names":["Cors","initMiddleware","bcrypt","jwt","isLength","users","User","enroled_courses","Enroled_courses","courses","Course","cors","methods","req","res","headers","status","json","message","method","handlePostRequest","handleGetRequest","handlePutRequest","send","currentPassword","newPassword","newConfirmPassword","body","userId","verify","authorization","process","env","JWT_SECRET","min","max","newPasswordHash","hash","user","findOne","attributes","where","id","match","compare","password","update","error","console","name","designation","location","description","exclude","include","model","as"],"mappings":"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","sourcesContent":["import Cors from 'cors'\nimport initMiddleware from '@/lib/init-middleware'\nimport bcrypt from 'bcrypt'\nimport jwt from 'jsonwebtoken'\nimport isLength from 'validator/lib/isLength'\nimport { \n    users as User,\n    enroled_courses as Enroled_courses,\n    courses as Course\n} from '@/models/index'\n\n// Initialize the cors middleware\nconst cors = initMiddleware(\n    // You can read more about the available options here: https://github.com/expressjs/cors#configuration-options\n    Cors({\n        // Only allow requests with GET, POST and OPTIONS\n        methods: ['GET', 'POST', 'OPTIONS', 'DELETE', 'PUT'],\n    })\n)\n\nexport default async (req, res) => {\n    await cors(req, res)\n    if(!(\"authorization\" in req.headers)){\n        return res.status(401).json({message: \"No autorization token\"});\n    }\n    switch(req.method){\n        case \"POST\":\n            await handlePostRequest(req, res);\n            break;\n        case \"GET\":\n            await handleGetRequest(req, res);\n            break;\n        case \"PUT\":\n            await handlePutRequest(req, res);\n            break;\n        default:\n            res.status(405).send(`Method ${req.method} not allowed`);\n    }\n}\n\nconst handlePostRequest = async (req, res) => {\n    const {currentPassword, newPassword, newConfirmPassword} = req.body\n    try {\n        const {userId} = jwt.verify(req.headers.authorization, process.env.JWT_SECRET)\n        // check email, name, password format\n        if (!currentPassword){\n            return res.status(422).send({message: \"Must be provide current Password!\"})\n        } else if (!isLength(newPassword, {min: 6, max: 12})){\n            return res.status(422).send({message: \"New Password must be 6-12 characters long!\"})\n        } else if (newPassword != newConfirmPassword){\n            return res.status(422).json({message: \"Confirm password doesn't matched!\"})\n        }\n\n        const newPasswordHash = await bcrypt.hash(newPassword, 10)\n\n        const user = await User.findOne({ \n            attributes: ['password'],\n            where: { id: userId }\n        })\n\n        const match = await bcrypt.compare(currentPassword, user.password)\n\n        if(!match){\n            return res.status(422).send({message: \"Current Password doesn't match!\"})\n        }\n\n        await User.update(\n            {\n                password: newPasswordHash\n            },\n            {\n                where: {id: userId}\n            }\n        )\n       \n        res.status(200).json({\"message\": \"Successfully updated the password!\"})\n    } catch (error) {\n        console.error(error)\n        res.status(403).json({message: \"Invalid token\"});\n    }\n}\n\nconst handlePutRequest = async (req, res) => {\n    const {name, designation, location, description} = req.body\n    try {\n        const {userId} = jwt.verify(req.headers.authorization, process.env.JWT_SECRET);\n        await User.update(\n            {\n                name: name,\n                designation: designation,\n                description: description,\n                location: location\n            },\n            {\n                where: {id: userId}\n            }\n        )\n       \n        res.status(200).json({\"message\": \"Successfully updated the profile!\"})\n    } catch (error) {\n        res.status(403).json({message: \"Invalid token\"});\n    }\n}\n\nconst handleGetRequest = async (req, res) => {\n    try {\n        const {userId} = jwt.verify(req.headers.authorization, process.env.JWT_SECRET);\n        const user = await User.findOne({ \n            attributes: {\n                exclude: ['password']\n            },\n            where: { id: userId },\n            include: [{\n                model: Enroled_courses, as: 'enroled_courses',\n                attributes: ['courseId']\n            }]\n        })\n        if(user){\n            res.status(200).json(user);\n        } else {\n            res.status(404).send(\"User not found\");\n        }\n    } catch (error) {\n        res.status(403).send(\"Invalid token\");\n    }\n}"]},"metadata":{},"sourceType":"module"}