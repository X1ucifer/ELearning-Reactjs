{"code":"(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[14],{NKCw:function(e,r,t){\"use strict\";t.d(r,\"a\",(function(){return me}));var n=t(\"q1tI\"),s=e=>e instanceof HTMLElement;const c=\"blur\",i=\"change\",u=\"input\",a=\"onBlur\",o=\"onChange\",l=\"onSubmit\",f=\"onTouched\",d=\"all\",b=\"undefined\",y=\"max\",g=\"min\",O=\"maxLength\",j=\"minLength\",h=\"pattern\",m=\"required\",v=\"validate\";var p=e=>null==e;const A=e=>\"object\"===typeof e;var V=e=>!p(e)&&!Array.isArray(e)&&A(e)&&!(e instanceof Date),w=e=>/^\\w*$/.test(e),R=e=>e.filter(Boolean),k=e=>R(e.replace(/[\"|']/g,\"\").replace(/\\[/g,\".\").replace(/\\]/g,\"\").split(\".\"));function C(e,r,t){let n=-1;const s=w(r)?[r]:k(r),c=s.length,i=c-1;for(;++n<c;){const r=s[n];let c=t;if(n!==i){const t=e[r];c=V(t)||Array.isArray(t)?t:isNaN(+s[n+1])?{}:[]}e[r]=c,e=e[r]}return e}var S=(e,r={})=>{for(const t in e)w(t)?r[t]=e[t]:C(r,t,e[t]);return r},D=e=>void 0===e,F=(e={},r,t)=>{const n=R(r.split(/[,[\\].]+?/)).reduce(((e,r)=>p(e)?e:e[r]),e);return D(n)||n===e?D(e[r])?t:e[r]:n},E=(e,r)=>{s(e)&&e.removeEventListener&&(e.removeEventListener(u,r),e.removeEventListener(i,r),e.removeEventListener(c,r))};const N={isValid:!1,value:null};var x=e=>Array.isArray(e)?e.reduce(((e,r)=>r&&r.ref.checked?{isValid:!0,value:r.ref.value}:e),N):N,L=e=>\"radio\"===e.type,B=e=>\"file\"===e.type,M=e=>\"checkbox\"===e.type,T=e=>\"select-multiple\"===e.type;const W={value:!1,isValid:!1},P={value:!0,isValid:!0};var $=e=>{if(Array.isArray(e)){if(e.length>1){const r=e.filter((e=>e&&e.ref.checked)).map((({ref:{value:e}})=>e));return{value:r,isValid:!!r.length}}const{checked:r,value:t,attributes:n}=e[0].ref;return r?n&&!D(n.value)?D(t)||\"\"===t?P:{value:t,isValid:!0}:P:W}return W};function _(e,r,t,n,s){const c=e.current[r];if(c){const{ref:{value:e,disabled:r},ref:t,valueAsNumber:u,valueAsDate:a,setValueAs:o}=c;if(r&&n)return;return B(t)?t.files:L(t)?x(c.options).value:T(t)?(i=t.options,[...i].filter((({selected:e})=>e)).map((({value:e})=>e))):M(t)?$(c.options).value:s?e:u?\"\"===e?NaN:+e:a?t.valueAsDate:o?o(e):e}var i;if(t)return F(t.current,r)}function q(e){return!e||e instanceof HTMLElement&&e.nodeType!==Node.DOCUMENT_NODE&&q(e.parentNode)}var H=e=>V(e)&&!Object.keys(e).length,U=e=>\"boolean\"===typeof e;function I(e,r){const t=w(r)?[r]:k(r),n=1==t.length?e:function(e,r){const t=r.slice(0,-1).length;let n=0;for(;n<t;)e=D(e)?n++:e[r[n++]];return e}(e,t),s=t[t.length-1];let c;n&&delete n[s];for(let i=0;i<t.slice(0,-1).length;i++){let r,n=-1;const s=t.slice(0,-(i+1)),u=s.length-1;for(i>0&&(c=e);++n<s.length;){const t=s[n];r=r?r[t]:e[t],u===n&&(V(r)&&H(r)||Array.isArray(r)&&!r.filter((e=>V(e)&&!H(e)||U(e))).length)&&(c?delete c[t]:delete e[t]),c=r}}return e}const J=(e,r)=>e&&e.ref===r;var z=e=>p(e)||!A(e);function K(e,r){if(z(e)||z(r))return r;for(const n in r){const s=e[n],c=r[n];try{e[n]=V(s)&&V(c)||Array.isArray(s)&&Array.isArray(c)?K(s,c):c}catch(t){}}return e}function G(e,r,t){if(z(e)||z(r)||e instanceof Date||r instanceof Date)return e===r;if(!Object(n.isValidElement)(e)){const n=Object.keys(e),s=Object.keys(r);if(n.length!==s.length)return!1;for(const c of n){const n=e[c];if(!t||\"ref\"!==c){const e=r[c];if((V(n)||Array.isArray(n))&&(V(e)||Array.isArray(e))?!G(n,e,t):n!==e)return!1}}}return!0}function Q(e,r,t,n,s){let c=-1;for(;++c<e.length;){for(const n in e[c])Array.isArray(e[c][n])?(!t[c]&&(t[c]={}),t[c][n]=[],Q(e[c][n],F(r[c]||{},n,[]),t[c][n],t[c],n)):G(F(r[c]||{},n),e[c][n])?C(t[c]||{},n):t[c]=Object.assign(Object.assign({},t[c]),{[n]:!0});n&&!t.length&&delete n[s]}return t}var X=(e,r,t)=>K(Q(e,r,t.slice(0,e.length)),Q(r,e,t.slice(0,e.length))),Y=e=>\"string\"===typeof e,Z=(e,r,t,n,s)=>{const c={};for(const i in e.current)(D(s)||(Y(s)?i.startsWith(s):Array.isArray(s)&&s.find((e=>i.startsWith(e)))))&&(c[i]=_(e,i,void 0,n));return t?S(c):K(r,S(c))},ee=e=>e instanceof RegExp,re=e=>V(e)&&!ee(e)?e:{value:e,message:\"\"},te=e=>\"function\"===typeof e,ne=e=>Y(e)||Object(n.isValidElement)(e);function se(e,r,t=\"validate\"){if(ne(e)||U(e)&&!e)return{type:t,message:ne(e)?e:\"\",ref:r}}var ce=(e,r,t,n,s)=>r?Object.assign(Object.assign({},t[e]),{types:Object.assign(Object.assign({},t[e]&&t[e].types?t[e].types:{}),{[n]:s||!0})}):{},ie=async(e,r,{ref:t,ref:{value:n},options:s,required:c,maxLength:i,minLength:u,min:a,max:o,pattern:l,validate:f},d)=>{const b=t.name,A={},w=L(t),R=M(t),k=w||R,C=\"\"===n,S=ce.bind(null,b,r,A),D=(e,r,n,s=O,c=j)=>{const i=e?r:n;A[b]=Object.assign({type:e?s:c,message:i,ref:t},S(e?s:c,i))};if(c&&(!w&&!R&&(C||p(n))||U(n)&&!n||R&&!$(s).isValid||w&&!x(s).isValid)){const{value:n,message:s}=ne(c)?{value:!!c,message:c}:re(c);if(n&&(A[b]=Object.assign({type:m,message:s,ref:k?((e.current[b].options||[])[0]||{}).ref:t},S(m,s)),!r))return A}if((!p(a)||!p(o))&&\"\"!==n){let e,s;const c=re(o),i=re(a);if(isNaN(n)){const r=t.valueAsDate||new Date(n);Y(c.value)&&(e=r>new Date(c.value)),Y(i.value)&&(s=r<new Date(i.value))}else{const r=t.valueAsNumber||parseFloat(n);p(c.value)||(e=r>c.value),p(i.value)||(s=r<i.value)}if((e||s)&&(D(!!e,c.message,i.message,y,g),!r))return A}if(Y(n)&&!C&&(i||u)){const e=re(i),t=re(u),s=!p(e.value)&&n.length>e.value,c=!p(t.value)&&n.length<t.value;if((s||c)&&(D(s,e.message,t.message),!r))return A}if(Y(n)&&l&&!C){const{value:e,message:s}=re(l);if(ee(e)&&!e.test(n)&&(A[b]=Object.assign({type:h,message:s,ref:t},S(h,s)),!r))return A}if(f){const n=_(e,b,d,!1,!0),c=k&&s?s[0].ref:t;if(te(f)){const e=se(await f(n),c);if(e&&(A[b]=Object.assign(Object.assign({},e),S(v,e.message)),!r))return A}else if(V(f)){let e={};for(const[t,s]of Object.entries(f)){if(!H(e)&&!r)break;const i=se(await s(n),c,t);i&&(e=Object.assign(Object.assign({},i),S(t,i.message)),r&&(A[b]=e))}if(!H(e)&&(A[b]=Object.assign({ref:c},e),!r))return A}}return A};const ue=(e,r,t=[])=>{for(const n in r){const s=e+(V(r)?`.${n}`:`[${n}]`);z(r[n])?t.push(s):ue(s,r[n],t)}return t};var ae=(e,r,t,n,s)=>{let c;return t.add(r),H(e)||(c=F(e,r),(V(c)||Array.isArray(c))&&ue(r,c).forEach((e=>t.add(e)))),D(c)?s?n:F(n,r):c},oe=({isOnBlur:e,isOnChange:r,isOnTouch:t,isTouched:n,isReValidateOnBlur:s,isReValidateOnChange:c,isBlurEvent:i,isSubmitted:u,isOnAll:a})=>!a&&(!u&&t?!(n||i):(u?s:e)?!i:!(u?c:r)||i),le=e=>e.substring(0,e.indexOf(\"[\"));const fe=(e,r)=>RegExp(`^${r}([|.)\\\\d+`.replace(/\\[/g,\"\\\\[\").replace(/\\]/g,\"\\\\]\")).test(e);var de=(e,r)=>[...e].some((e=>fe(r,e)));var be=typeof window!==b&&typeof document!==b;function ye(e){var r;let t;if(z(e)||be&&(e instanceof File||s(e)))return e;if(![\"Set\",\"Map\",\"Object\",\"Date\",\"Array\"].includes(null===(r=e.constructor)||void 0===r?void 0:r.name))return e;if(e instanceof Date)return t=new Date(e.getTime()),t;if(e instanceof Set){t=new Set;for(const r of e)t.add(r);return t}if(e instanceof Map){t=new Map;for(const r of e.keys())t.set(r,ye(e.get(r)));return t}t=Array.isArray(e)?[]:{};for(const n in e)t[n]=ye(e[n]);return t}var ge=e=>({isOnSubmit:!e||e===l,isOnBlur:e===a,isOnChange:e===o,isOnAll:e===d,isOnTouch:e===f}),Oe=e=>L(e)||M(e);const je=typeof window===b,he=be?\"Proxy\"in window:typeof Proxy!==b;function me({mode:e=l,reValidateMode:r=o,resolver:t,context:a,defaultValues:f={},shouldFocusError:b=!0,shouldUnregister:y=!0,criteriaMode:g}={}){const O=Object(n.useRef)({}),j=Object(n.useRef)({}),h=Object(n.useRef)({}),m=Object(n.useRef)(new Set),v=Object(n.useRef)({}),A=Object(n.useRef)({}),k=Object(n.useRef)({}),N=Object(n.useRef)({}),x=Object(n.useRef)(f),W=Object(n.useRef)(!1),P=Object(n.useRef)(!1),$=Object(n.useRef)(),U=Object(n.useRef)({}),K=Object(n.useRef)({}),Q=Object(n.useRef)(a),ee=Object(n.useRef)(t),re=Object(n.useRef)(new Set),ne=Object(n.useRef)(ge(e)),{isOnSubmit:se,isOnTouch:ce}=ne.current,fe=g===d,[me,ve]=Object(n.useState)({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touched:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!se,errors:{}}),pe=Object(n.useRef)({isDirty:!he,dirtyFields:!he,touched:!he||ce,isValidating:!he,isSubmitting:!he,isValid:!he}),Ae=Object(n.useRef)(me),Ve=Object(n.useRef)(),{isOnBlur:we,isOnChange:Re}=Object(n.useRef)(ge(r)).current;Q.current=a,ee.current=t,Ae.current=me,U.current=y?{}:H(U.current)?ye(f):U.current;const ke=Object(n.useCallback)(((e={})=>{W.current||(Ae.current=Object.assign(Object.assign({},Ae.current),e),ve(Ae.current))}),[]),Ce=()=>pe.current.isValidating&&ke({isValidating:!0}),Se=Object(n.useCallback)(((e,r,t=!1,n={},s)=>{let c=t||(({errors:e,name:r,error:t,validFields:n,fieldsWithValidation:s})=>{const c=D(t),i=F(e,r);return c&&!!i||!c&&!G(i,t,!0)||c&&F(s,r)&&!F(n,r)})({errors:Ae.current.errors,error:r,name:e,validFields:N.current,fieldsWithValidation:k.current});const i=F(Ae.current.errors,e);r?(I(N.current,e),c=c||!i||!G(i,r,!0),C(Ae.current.errors,e,r)):((F(k.current,e)||ee.current)&&(C(N.current,e,!0),c=c||i),I(Ae.current.errors,e)),(c&&!p(t)||!H(n)||pe.current.isValidating)&&ke(Object.assign(Object.assign(Object.assign({},n),ee.current?{isValid:!!s}:{}),{isValidating:!1}))}),[]),De=Object(n.useCallback)(((e,r)=>{const{ref:t,options:n}=O.current[e],c=be&&s(t)&&p(r)?\"\":r;L(t)?(n||[]).forEach((({ref:e})=>e.checked=e.value===c)):B(t)&&!Y(c)?t.files=c:T(t)?[...t.options].forEach((e=>e.selected=c.includes(e.value))):M(t)&&n?n.length>1?n.forEach((({ref:e})=>e.checked=Array.isArray(c)?!!c.find((r=>r===e.value)):c===e.value)):n[0].ref.checked=!!c:t.value=c}),[]),Fe=Object(n.useCallback)(((e,r)=>{if(pe.current.isDirty){const t=$e();return e&&r&&C(t,e,r),!G(t,x.current)}return!1}),[]),Ee=Object(n.useCallback)(((e,r=!0)=>{if(pe.current.isDirty||pe.current.dirtyFields){const t=!G(F(x.current,e),_(O,e,U)),n=F(Ae.current.dirtyFields,e),s=Ae.current.isDirty;t?C(Ae.current.dirtyFields,e,!0):I(Ae.current.dirtyFields,e);const c={isDirty:Fe(),dirtyFields:Ae.current.dirtyFields},i=pe.current.isDirty&&s!==c.isDirty||pe.current.dirtyFields&&n!==F(Ae.current.dirtyFields,e);return i&&r&&ke(c),i?c:{}}return{}}),[]),Ne=Object(n.useCallback)((async(e,r)=>{const t=(await ie(O,fe,O.current[e],U))[e];return Se(e,t,r),D(t)}),[Se,fe]),xe=Object(n.useCallback)((async e=>{const{errors:r}=await ee.current($e(),Q.current,fe),t=Ae.current.isValid;if(Array.isArray(e)){const t=e.map((e=>{const t=F(r,e);return t?C(Ae.current.errors,e,t):I(Ae.current.errors,e),!t})).every(Boolean);return ke({isValid:H(r),isValidating:!1}),t}{const n=F(r,e);return Se(e,n,t!==H(r),{},H(r)),!n}}),[Se,fe]),Le=Object(n.useCallback)((async e=>{const r=e||Object.keys(O.current);if(Ce(),ee.current)return xe(r);if(Array.isArray(r)){!e&&(Ae.current.errors={});const t=await Promise.all(r.map((async e=>await Ne(e,null))));return ke({isValidating:!1}),t.every(Boolean)}return await Ne(r)}),[xe,Ne]),Be=Object(n.useCallback)(((e,r,{shouldDirty:t,shouldValidate:n})=>{const s={};C(s,e,r);for(const c of ue(e,r))O.current[c]&&(De(c,F(s,c)),t&&Ee(c),n&&Le(c))}),[Le,De,Ee]),Me=Object(n.useCallback)(((e,r,t)=>{if(!y&&!z(r)&&C(U.current,e,Array.isArray(r)?[...r]:Object.assign({},r)),O.current[e])De(e,r),t.shouldDirty&&Ee(e),t.shouldValidate&&Le(e);else if(!z(r)&&(Be(e,r,t),re.current.has(e))){const n=le(e)||e;C(j.current,e,r),K.current[n]({[n]:F(j.current,n)}),(pe.current.isDirty||pe.current.dirtyFields)&&t.shouldDirty&&(C(Ae.current.dirtyFields,e,X(r,F(x.current,e,[]),F(Ae.current.dirtyFields,e,[]))),ke({isDirty:!G(Object.assign(Object.assign({},$e()),{[e]:r}),x.current)}))}!y&&C(U.current,e,r)}),[Ee,De,Be]),Te=e=>P.current||m.current.has(e)||m.current.has((e.match(/\\w+/)||[])[0]),We=e=>{let r=!0;if(!H(v.current))for(const t in v.current)e&&v.current[t].size&&!v.current[t].has(e)&&!v.current[t].has(le(e))||(A.current[t](),r=!1);return r};function Pe(e){if(!y){let r=ye(e);for(const e of re.current)w(e)&&!r[e]&&(r=Object.assign(Object.assign({},r),{[e]:[]}));return r}return e}function $e(e){if(Y(e))return _(O,e,U);if(Array.isArray(e)){const r={};for(const t of e)C(r,t,_(O,t,U));return r}return Pe(Z(O,ye(U.current),y))}$.current=$.current?$.current:async({type:e,target:r})=>{let t=r.name;const n=O.current[t];let s,i;if(n){const u=e===c,a=oe(Object.assign({isBlurEvent:u,isReValidateOnChange:Re,isReValidateOnBlur:we,isTouched:!!F(Ae.current.touched,t),isSubmitted:Ae.current.isSubmitted},ne.current));let o=Ee(t,!1),l=!H(o)||!u&&Te(t);if(u&&!F(Ae.current.touched,t)&&pe.current.touched&&(C(Ae.current.touched,t,!0),o=Object.assign(Object.assign({},o),{touched:Ae.current.touched})),!y&&M(r)&&C(U.current,t,_(O,t)),a)return!u&&We(t),(!H(o)||l&&H(o))&&ke(o);if(Ce(),ee.current){const{errors:e}=await ee.current($e(),Q.current,fe),n=Ae.current.isValid;if(s=F(e,t),M(r)&&!s&&ee.current){const r=le(t),n=F(e,r,{});n.type&&n.message&&(s=n),r&&(n||F(Ae.current.errors,r))&&(t=r)}i=H(e),n!==i&&(l=!0)}else s=(await ie(O,fe,n,U))[t];!u&&We(t),Se(t,s,l,o,i)}};const _e=Object(n.useCallback)((async(e={})=>{const r=H(O.current)?x.current:{},{errors:t}=await ee.current(Object.assign(Object.assign(Object.assign({},r),$e()),e),Q.current,fe)||{},n=H(t);Ae.current.isValid!==n&&ke({isValid:n})}),[fe]),qe=Object(n.useCallback)(((e,r)=>{!function(e,r,t,n,s,c){const{ref:i,ref:{name:u}}=t,a=e.current[u];if(!s){const r=_(e,u,n);!D(r)&&C(n.current,u,r)}i.type&&a?L(i)||M(i)?Array.isArray(a.options)&&a.options.length?(R(a.options).forEach(((e={},t)=>{(q(e.ref)&&J(e,e.ref)||c)&&(E(e.ref,r),I(a.options,`[${t}]`))})),a.options&&!R(a.options).length&&delete e.current[u]):delete e.current[u]:(q(i)&&J(a,i)||c)&&(E(i,r),delete e.current[u]):delete e.current[u]}(O,$.current,e,U,y,r),y&&(I(N.current,e.ref.name),I(k.current,e.ref.name))}),[y]),He=Object(n.useCallback)((e=>{if(P.current)ke();else{for(const r of m.current)if(r.startsWith(e)){ke();break}We(e)}}),[]),Ue=Object(n.useCallback)(((e,r)=>{e&&(qe(e,r),y&&!R(e.options||[]).length&&(I(Ae.current.errors,e.ref.name),C(Ae.current.dirtyFields,e.ref.name,!0),ke({isDirty:Fe()}),pe.current.isValid&&ee.current&&_e(),He(e.ref.name)))}),[_e,qe]);const Ie=Object(n.useCallback)(((e,r,t)=>{const n=t?v.current[t]:m.current;let s=Z(O,ye(U.current),y,!1,e);if(Y(e)){const t=le(e)||e;return re.current.has(t)&&(s=Object.assign(Object.assign({},h.current),s)),ae(s,e,n,D(F(x.current,e))?r:F(x.current,e),!0)}const c=D(r)?x.current:r;return Array.isArray(e)?e.reduce(((e,r)=>Object.assign(Object.assign({},e),{[r]:ae(s,r,n,c)})),{}):(P.current=D(t),S(!H(s)&&s||c))}),[]);function Je(e,r={}){const{name:t,type:n,value:a}=e,o=Object.assign({ref:e},r),l=O.current,f=Oe(e),d=de(re.current,t),b=r=>be&&(!s(e)||r===e);let g,j=l[t],h=!0;if(j&&(f?Array.isArray(j.options)&&R(j.options).find((e=>a===e.ref.value&&b(e.ref))):b(j.ref)))return void(l[t]=Object.assign(Object.assign({},j),r));j=n?f?Object.assign({options:[...R(j&&j.options||[]),{ref:e}],ref:{type:n,name:t}},r):Object.assign({},o):o,l[t]=j;const m=D(F(U.current,t));H(x.current)&&m||(g=F(m?x.current:U.current,t),h=D(g),h||d||De(t,g)),H(r)||(C(k.current,t,!0),!se&&pe.current.isValid&&ie(O,fe,j,U).then((e=>{const r=Ae.current.isValid;H(e)?C(N.current,t,!0):I(N.current,t),r!==H(e)&&ke()}))),!y||d&&h||!d&&I(Ae.current.dirtyFields,t),n&&function({ref:e},r,t){s(e)&&t&&(e.addEventListener(r?i:u,t),e.addEventListener(c,t))}(f&&j.options?j.options[j.options.length-1]:j,f||\"select-one\"===e.type,$.current)}const ze=Object(n.useCallback)(((e,r)=>async t=>{t&&t.preventDefault&&(t.preventDefault(),t.persist());let n={},s=Pe(Z(O,ye(U.current),y,!0));pe.current.isSubmitting&&ke({isSubmitting:!0});try{if(ee.current){const{errors:e,values:r}=await ee.current(s,Q.current,fe);Ae.current.errors=n=e,s=r}else for(const e of Object.values(O.current))if(e){const{name:r}=e.ref,t=await ie(O,fe,e,U);t[r]?(C(n,r,t[r]),I(N.current,r)):F(k.current,r)&&(I(Ae.current.errors,r),C(N.current,r,!0))}H(n)&&Object.keys(Ae.current.errors).every((e=>e in O.current))?(ke({errors:{},isSubmitting:!0}),await e(s,t)):(Ae.current.errors=Object.assign(Object.assign({},Ae.current.errors),n),r&&await r(Ae.current.errors,t),b&&((e,r)=>{for(const t in e)if(F(r,t)){const r=e[t];if(r){if(r.ref.focus&&D(r.ref.focus()))break;if(r.options){r.options[0].ref.focus();break}}}})(O.current,Ae.current.errors))}finally{Ae.current.isSubmitting=!1,ke({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:H(Ae.current.errors),submitCount:Ae.current.submitCount+1})}}),[b,fe]);Object(n.useEffect)((()=>{t&&pe.current.isValid&&_e(),Ve.current=Ve.current||!be?Ve.current:function(e,r){const t=new MutationObserver((()=>{for(const t of Object.values(e.current))if(t&&t.options)for(const e of t.options)e&&e.ref&&q(e.ref)&&r(t);else t&&q(t.ref)&&r(t)}));return t.observe(window.document,{childList:!0,subtree:!0}),t}(O,Ue)}),[Ue,x.current]),Object(n.useEffect)((()=>()=>{Ve.current&&Ve.current.disconnect(),W.current=!0,Object.values(O.current).forEach((e=>Ue(e,!0)))}),[]),!t&&pe.current.isValid&&(me.isValid=G(N.current,k.current)&&H(Ae.current.errors));const Ke={trigger:Le,setValue:Object(n.useCallback)((function(e,r,t){Me(e,r,t||{}),Te(e)&&ke(),We(e)}),[Me,Le]),getValues:Object(n.useCallback)($e,[]),register:Object(n.useCallback)((function(e,r){if(!je)if(Y(e))Je({name:e},r);else{if(!V(e)||!(\"name\"in e))return r=>r&&Je(r,e);Je(e,r)}}),[x.current]),unregister:Object(n.useCallback)((function(e){for(const r of Array.isArray(e)?e:[e])Ue(O.current[r],!0)}),[]),formState:he?new Proxy(me,{get:(e,r)=>{if(r in e)return pe.current[r]=!0,e[r]}}):me},Ge=Object(n.useMemo)((()=>Object.assign({isFormDirty:Fe,updateWatchedValue:He,shouldUnregister:y,updateFormState:ke,removeFieldEventListener:qe,watchInternal:Ie,mode:ne.current,reValidateMode:{isReValidateOnBlur:we,isReValidateOnChange:Re},validateResolver:t?_e:void 0,fieldsRef:O,resetFieldArrayFunctionRef:K,useWatchFieldsRef:v,useWatchRenderFunctionsRef:A,fieldArrayDefaultValuesRef:j,validFieldsRef:N,fieldsWithValidationRef:k,fieldArrayNamesRef:re,readFormStateRef:pe,formStateRef:Ae,defaultValuesRef:x,shallowFieldsStateRef:U,fieldArrayValuesRef:h},Ke)),[x.current,He,y,qe,Ie]);return Object.assign({watch:function(e,r){return Ie(e,r)},control:Ge,handleSubmit:ze,reset:Object(n.useCallback)(((e,r={})=>{if(be)for(const n of Object.values(O.current))if(n){const{ref:e,options:r}=n,c=Oe(e)&&Array.isArray(r)?r[0].ref:e;if(s(c))try{c.closest(\"form\").reset();break}catch(t){}}O.current={},x.current=Object.assign({},e||x.current),e&&We(\"\"),Object.values(K.current).forEach((e=>te(e)&&e())),U.current=y?{}:ye(e||x.current),(({errors:e,isDirty:r,isSubmitted:t,touched:n,isValid:s,submitCount:c,dirtyFields:i})=>{s||(N.current={},k.current={}),j.current={},m.current=new Set,P.current=!1,ke({submitCount:c?Ae.current.submitCount:0,isDirty:!!r&&Ae.current.isDirty,isSubmitted:!!t&&Ae.current.isSubmitted,isValid:!!s&&Ae.current.isValid,dirtyFields:i?Ae.current.dirtyFields:{},touched:n?Ae.current.touched:{},errors:e?Ae.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1})})(r)}),[]),clearErrors:Object(n.useCallback)((function(e){e&&(Array.isArray(e)?e:[e]).forEach((e=>O.current[e]&&w(e)?delete Ae.current.errors[e]:I(Ae.current.errors,e))),ke({errors:e?Ae.current.errors:{}})}),[]),setError:Object(n.useCallback)((function(e,r){const t=(O.current[e]||{}).ref;C(Ae.current.errors,e,Object.assign(Object.assign({},r),{ref:t})),ke({isValid:!1}),r.shouldFocus&&t&&t.focus&&t.focus()}),[]),errors:me.errors},Ke)}const ve=Object(n.createContext)(null);ve.displayName=\"RHFContext\"},rePB:function(e,r,t){\"use strict\";function n(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}t.d(r,\"a\",(function(){return n}))}}]);","map":{"version":3,"sources":["static/chunks/54e29b85d2771d91a461a130fb8c5814d959012c.9972333746fbfb14d1f7.js"],"names":["window","push","NKCw","module","__webpack_exports__","__webpack_require__","d","useForm","react__WEBPACK_IMPORTED_MODULE_0__","isHTMLElement","value","HTMLElement","EVENTS","VALIDATION_MODE","UNDEFINED","INPUT_VALIDATION_RULES","isNullOrUndefined","isObjectType","isObject","Array","isArray","Date","isKey","test","compact","filter","Boolean","stringToPath","input","replace","split","set","object","path","index","tempPath","length","lastIndex","key","newValue","objValue","isNaN","transformToNestObject","data","isUndefined","val","undefined","get","obj","defaultValue","result","reduce","removeAllEventListeners","ref","validateWithStateUpdate","removeEventListener","defaultReturn","isValid","getRadioValue","options","previous","option","checked","isRadioInput","element","type","isFileInput","isCheckBoxInput","isMultipleSelect","defaultResult","validResult","getCheckboxValue","values","map","attributes","getFieldValue","fieldsRef","name","shallowFieldsStateRef","excludeDisabled","shouldKeepRawValue","field","current","disabled","valueAsNumber","valueAsDate","setValueAs","files","selected","NaN","isDetached","nodeType","Node","DOCUMENT_NODE","parentNode","isEmptyObject","Object","keys","isBoolean","unset","updatePath","childObject","slice","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","isSameRef","fieldValue","isPrimitive","deepMerge","target","source","targetValue","sourceValue","_a","deepEqual","object1","object2","isErrorObject","keys1","keys2","val1","val2","setDirtyFields","defaultValues","dirtyFields","parentName","assign","[object Object]","setFieldArrayDirtyFields","isString","getFieldsValues","shallowFieldsState","shouldUnregister","search","output","startsWith","find","isRegex","RegExp","getValueAndMessage","validationData","message","isFunction","isMessage","getValidateError","appendErrors","validateAllFieldCriteria","errors","types","validateField","async","required","maxLength","minLength","min","max","pattern","validate","error","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","exceedMin","maxOutput","minOutput","valueDate","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","validateRef","validateError","validationResult","validateFunction","entries","getPath","rootPath","paths","property","rootName","assignWatchFields","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","forEach","skipValidation","isOnBlur","isOnChange","isOnTouch","isTouched","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","getFieldArrayParentName","substring","indexOf","isMatchFieldArrayName","searchName","isNameInFieldArray","names","some","isWeb","document","cloneObject","copy","File","includes","constructor","getTime","Set","Map","modeChecker","mode","isOnSubmit","isRadioOrCheckboxFunction","isWindowUndefined","isProxyEnabled","Proxy","reValidateMode","resolver","context","shouldFocusError","criteriaMode","fieldArrayDefaultValuesRef","fieldArrayValuesRef","watchFieldsRef","useWatchFieldsRef","useWatchRenderFunctionsRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","isUnMount","isWatchAllRef","handleChangeRef","resetFieldArrayFunctionRef","contextRef","resolverRef","fieldArrayNamesRef","modeRef","isValidateAllFieldCriteria","formState","setFormState","isDirty","isValidating","submitCount","touched","isSubmitting","isSubmitSuccessful","readFormStateRef","formStateRef","observerRef","updateFormState","state","updateIsValidating","shouldRenderBaseOnError","shouldRender","shouldReRender","validFields","fieldsWithValidation","previousError","isErrorStateChanged","setFieldValue","rawValue","radioRef","selectRef","checkboxRef","isFormDirty","formValues","getValues","updateAndGetDirtyState","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","executeSchemaOrResolverValidation","previousFormIsValid","isInputsValid","every","trigger","fields","Promise","all","setInternalValues","shouldDirty","shouldValidate","setInternalValue","config","has","isFieldWatched","match","renderWatchedInputs","found","size","setFieldArrayDefaultValues","payload","shouldSkipValidation","parentNodeName","currentError","validateResolver","newDefaultValues","removeFieldEventListener","forceDelete","handleChange","fieldRef","findRemovedFieldAndRemoveListener","updateWatchedValue","watchField","removeFieldEventListenerAndRef","watchInternal","fieldNames","watchId","combinedDefaultValues","registerFieldRef","fieldRefAndValidationOptions","isFieldArray","compareRef","currentRef","isEmptyDefaultValue","isEmptyUnmountFields","then","shouldAttachChangeEvent","addEventListener","attachEventListeners","handleSubmit","onValid","onInvalid","e","preventDefault","persist","fieldErrors","fieldError","focus","focusOnErrorField","observer","MutationObserver","observe","childList","subtree","onDomRemove","disconnect","commonProps","setValue","register","refOrRegisterOptions","unregister","prop","control","watch","reset","omitResetState","inputRef","closest","resetFieldArray","resetRefs","clearErrors","inputName","setError","shouldFocus","FormContext","displayName","rePB","_defineProperty","defineProperty","enumerable","configurable","writable"],"mappings":"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"},"name":"static/chunks/54e29b85d2771d91a461a130fb8c5814d959012c.9972333746fbfb14d1f7.js","input":"(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[14],{\n\n/***/ \"NKCw\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export Controller */\n/* unused harmony export FormProvider */\n/* unused harmony export appendErrors */\n/* unused harmony export get */\n/* unused harmony export transformToNestObject */\n/* unused harmony export useController */\n/* unused harmony export useFieldArray */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return useForm; });\n/* unused harmony export useFormContext */\n/* unused harmony export useWatch */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ ref }, shouldAttachChangeEvent, handleChange) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar stringToPath = (input) => compact(input\r\n    .replace(/[\"|']/g, '')\r\n    .replace(/\\[/g, '.')\r\n    .replace(/\\]/g, '')\r\n    .split('.'));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data, value = {}) => {\r\n    for (const key in data) {\r\n        !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\r\n    }\r\n    return value;\r\n};\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj = {}, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus && isUndefined(field.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || value === ''\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled, shouldKeepRawValue) {\r\n    const field = fieldsRef.current[name];\r\n    if (field) {\r\n        const { ref: { value, disabled }, ref, valueAsNumber, valueAsDate, setValueAs, } = field;\r\n        if (disabled && excludeDisabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field.options).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field.options).value;\r\n        }\r\n        return shouldKeepRawValue\r\n            ? value\r\n            : valueAsNumber\r\n                ? value === ''\r\n                    ? NaN\r\n                    : +value\r\n                : valueAsDate\r\n                    ? ref.valueAsDate\r\n                    : setValueAs\r\n                        ? setValueAs(value)\r\n                        : value;\r\n    }\r\n    if (shallowFieldsStateRef) {\r\n        return get(shallowFieldsStateRef.current, name);\r\n    }\r\n}\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\r\n    const { ref, ref: { name }, } = field;\r\n    const fieldRef = fieldsRef.current[name];\r\n    if (!shouldUnregister) {\r\n        const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\r\n    }\r\n    if (!ref.type || !fieldRef) {\r\n        delete fieldsRef.current[name];\r\n        return;\r\n    }\r\n    if (isRadioInput(ref) || isCheckBoxInput(ref)) {\r\n        if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\r\n            compact(fieldRef.options).forEach((option = {}, index) => {\r\n                if ((isDetached(option.ref) && isSameRef(option, option.ref)) ||\r\n                    forceDelete) {\r\n                    removeAllEventListeners(option.ref, handleChange);\r\n                    unset(fieldRef.options, `[${index}]`);\r\n                }\r\n            });\r\n            if (fieldRef.options && !compact(fieldRef.options).length) {\r\n                delete fieldsRef.current[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fieldsRef.current[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        delete fieldsRef.current[name];\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) => {\r\n    const output = {};\r\n    for (const name in fieldsRef.current) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : Array.isArray(search) && search.find((data) => name.startsWith(data)))) {\r\n            output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\r\n        }\r\n    }\r\n    return shouldUnregister\r\n        ? transformToNestObject(output)\r\n        : deepMerge(shallowFieldsState, transformToNestObject(output));\r\n};\n\nvar isErrorStateChanged = ({ errors, name, error, validFields, fieldsWithValidation, }) => {\r\n    const isValid = isUndefined(error);\r\n    const previousError = get(errors, name);\r\n    return ((isValid && !!previousError) ||\r\n        (!isValid && !deepEqual(previousError, error, true)) ||\r\n        (isValid && get(fieldsWithValidation, name) && !get(validFields, name)));\r\n};\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(value);\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { value }, options, required, maxLength, minLength, min, max, pattern, validate, }, shallowFieldsStateRef) => {\r\n    const name = ref.name;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = value === '';\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox\r\n                    ? ((fieldsRef.current[name].options || [])[0] || {}).ref\r\n                    : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && value !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(value)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            value.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            value.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef, false, true);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst getPath = (rootPath, values, paths = []) => {\r\n    for (const property in values) {\r\n        const rootName = (rootPath +\r\n            (isObject(values)\r\n                ? `.${property}`\r\n                : `[${property}]`));\r\n        isPrimitive(values[property])\r\n            ? paths.push(rootName)\r\n            : getPath(rootName, values[property], paths);\r\n    }\r\n    return paths;\r\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value = undefined;\r\n    watchFields.add(fieldName);\r\n    if (!isEmptyObject(fieldValues)) {\r\n        value = get(fieldValues, fieldName);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            getPath(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\r\n    const observer = new MutationObserver(() => {\r\n        for (const field of Object.values(fieldsRef.current)) {\r\n            if (field && field.options) {\r\n                for (const option of field.options) {\r\n                    if (option && option.ref && isDetached(option.ref)) {\r\n                        removeFieldEventListenerAndRef(field);\r\n                    }\r\n                }\r\n            }\r\n            else if (field && isDetached(field.ref)) {\r\n                removeFieldEventListenerAndRef(field);\r\n            }\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar isWeb = typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n\nfunction cloneObject(data) {\r\n    var _a;\r\n    let copy;\r\n    if (isPrimitive(data) ||\r\n        (isWeb && (data instanceof File || isHTMLElement(data)))) {\r\n        return data;\r\n    }\r\n    if (!['Set', 'Map', 'Object', 'Date', 'Array'].includes((_a = data.constructor) === null || _a === void 0 ? void 0 : _a.name)) {\r\n        return data;\r\n    }\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n        return copy;\r\n    }\r\n    if (data instanceof Set) {\r\n        copy = new Set();\r\n        for (const item of data) {\r\n            copy.add(item);\r\n        }\r\n        return copy;\r\n    }\r\n    if (data instanceof Map) {\r\n        copy = new Map();\r\n        for (const key of data.keys()) {\r\n            copy.set(key, cloneObject(data.get(key)));\r\n        }\r\n        return copy;\r\n    }\r\n    copy = Array.isArray(data) ? [] : {};\r\n    for (const key in data) {\r\n        copy[key] = cloneObject(data[key]);\r\n    }\r\n    return copy;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = true, criteriaMode, } = {}) {\r\n    const fieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const fieldArrayDefaultValuesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const fieldArrayValuesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const watchFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const useWatchFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const useWatchRenderFunctionsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const fieldsWithValidationRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const validFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const defaultValuesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(defaultValues);\r\n    const isUnMount = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isWatchAllRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const handleChangeRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\r\n    const shallowFieldsStateRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const resetFieldArrayFunctionRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const contextRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(context);\r\n    const resolverRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(resolver);\r\n    const fieldArrayNamesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const modeRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(modeChecker(mode));\r\n    const { isOnSubmit, isOnTouch } = modeRef.current;\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touched: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touched: !isProxyEnabled || isOnTouch,\r\n        isValidating: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const formStateRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(formState);\r\n    const observerRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\r\n    const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(modeChecker(reValidateMode)).current;\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    formStateRef.current = formState;\r\n    shallowFieldsStateRef.current = shouldUnregister\r\n        ? {}\r\n        : isEmptyObject(shallowFieldsStateRef.current)\r\n            ? cloneObject(defaultValues)\r\n            : shallowFieldsStateRef.current;\r\n    const updateFormState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((state = {}) => {\r\n        if (!isUnMount.current) {\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\r\n            setFormState(formStateRef.current);\r\n        }\r\n    }, []);\r\n    const updateIsValidating = () => readFormStateRef.current.isValidating &&\r\n        updateFormState({\r\n            isValidating: true,\r\n        });\r\n    const shouldRenderBaseOnError = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, error, shouldRender = false, state = {}, isValid) => {\r\n        let shouldReRender = shouldRender ||\r\n            isErrorStateChanged({\r\n                errors: formStateRef.current.errors,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state) ||\r\n            readFormStateRef.current.isValidating) {\r\n            updateFormState(Object.assign(Object.assign(Object.assign({}, state), (resolverRef.current ? { isValid: !!isValid } : {})), { isValidating: false }));\r\n        }\r\n    }, []);\r\n    const setFieldValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, rawValue) => {\r\n        const { ref, options } = fieldsRef.current[name];\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref)) {\r\n            (options || []).forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref) && !isString(value)) {\r\n            ref.files = value;\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = Array.isArray(value)\r\n                    ? !!value.find((data) => data === checkboxRef.value)\r\n                    : value === checkboxRef.value))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, []);\r\n    const isFormDirty = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, data) => {\r\n        if (readFormStateRef.current.isDirty) {\r\n            const formValues = getValues();\r\n            name && data && set(formValues, name, data);\r\n            return !deepEqual(formValues, defaultValuesRef.current);\r\n        }\r\n        return false;\r\n    }, []);\r\n    const updateAndGetDirtyState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            const state = {\r\n                isDirty: isFormDirty(),\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && updateFormState(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (name, skipReRender) => {\r\n        if (false) {}\r\n        const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (names) => {\r\n        const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n        const previousFormIsValid = formStateRef.current.isValid;\r\n        if (Array.isArray(names)) {\r\n            const isInputsValid = names\r\n                .map((name) => {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(formStateRef.current.errors, name, error)\r\n                    : unset(formStateRef.current.errors, name);\r\n                return !error;\r\n            })\r\n                .every(Boolean);\r\n            updateFormState({\r\n                isValid: isEmptyObject(errors),\r\n                isValidating: false,\r\n            });\r\n            return isInputsValid;\r\n        }\r\n        else {\r\n            const error = get(errors, names);\r\n            shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\r\n            return !error;\r\n        }\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const trigger = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (name) => {\r\n        const fields = name || Object.keys(fieldsRef.current);\r\n        updateIsValidating();\r\n        if (resolverRef.current) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (Array.isArray(fields)) {\r\n            !name && (formStateRef.current.errors = {});\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n            updateFormState({\r\n                isValidating: false,\r\n            });\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, value, { shouldDirty, shouldValidate }) => {\r\n        const data = {};\r\n        set(data, name, value);\r\n        for (const fieldName of getPath(name, value)) {\r\n            if (fieldsRef.current[fieldName]) {\r\n                setFieldValue(fieldName, get(data, fieldName));\r\n                shouldDirty && updateAndGetDirtyState(fieldName);\r\n                shouldValidate && trigger(fieldName);\r\n            }\r\n        }\r\n    }, [trigger, setFieldValue, updateAndGetDirtyState]);\r\n    const setInternalValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, value, config) => {\r\n        !shouldUnregister &&\r\n            !isPrimitive(value) &&\r\n            set(shallowFieldsStateRef.current, name, Array.isArray(value) ? [...value] : Object.assign({}, value));\r\n        if (fieldsRef.current[name]) {\r\n            setFieldValue(name, value);\r\n            config.shouldDirty && updateAndGetDirtyState(name);\r\n            config.shouldValidate && trigger(name);\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value, config);\r\n            if (fieldArrayNamesRef.current.has(name)) {\r\n                const parentName = getFieldArrayParentName(name) || name;\r\n                set(fieldArrayDefaultValuesRef.current, name, value);\r\n                resetFieldArrayFunctionRef.current[parentName]({\r\n                    [parentName]: get(fieldArrayDefaultValuesRef.current, parentName),\r\n                });\r\n                if ((readFormStateRef.current.isDirty ||\r\n                    readFormStateRef.current.dirtyFields) &&\r\n                    config.shouldDirty) {\r\n                    set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                    updateFormState({\r\n                        isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), { [name]: value }), defaultValuesRef.current),\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\r\n    }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const renderWatchedInputs = (name) => {\r\n        let found = true;\r\n        if (!isEmptyObject(useWatchFieldsRef.current)) {\r\n            for (const key in useWatchFieldsRef.current) {\r\n                if (!name ||\r\n                    !useWatchFieldsRef.current[key].size ||\r\n                    useWatchFieldsRef.current[key].has(name) ||\r\n                    useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\r\n                    useWatchRenderFunctionsRef.current[key]();\r\n                    found = false;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    };\r\n    function setValue(name, value, config) {\r\n        setInternalValue(name, value, config || {});\r\n        isFieldWatched(name) && updateFormState();\r\n        renderWatchedInputs(name);\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            let name = target.name;\r\n            const field = fieldsRef.current[name];\r\n            let error;\r\n            let isValid;\r\n            if (field) {\r\n                const isBlurEvent = type === EVENTS.BLUR;\r\n                const shouldSkipValidation = skipValidation(Object.assign({ isBlurEvent,\r\n                    isReValidateOnChange,\r\n                    isReValidateOnBlur, isTouched: !!get(formStateRef.current.touched, name), isSubmitted: formStateRef.current.isSubmitted }, modeRef.current));\r\n                let state = updateAndGetDirtyState(name, false);\r\n                let shouldRender = !isEmptyObject(state) ||\r\n                    (!isBlurEvent && isFieldWatched(name));\r\n                if (isBlurEvent &&\r\n                    !get(formStateRef.current.touched, name) &&\r\n                    readFormStateRef.current.touched) {\r\n                    set(formStateRef.current.touched, name, true);\r\n                    state = Object.assign(Object.assign({}, state), { touched: formStateRef.current.touched });\r\n                }\r\n                if (!shouldUnregister && isCheckBoxInput(target)) {\r\n                    set(shallowFieldsStateRef.current, name, getFieldValue(fieldsRef, name));\r\n                }\r\n                if (shouldSkipValidation) {\r\n                    !isBlurEvent && renderWatchedInputs(name);\r\n                    return ((!isEmptyObject(state) ||\r\n                        (shouldRender && isEmptyObject(state))) &&\r\n                        updateFormState(state));\r\n                }\r\n                updateIsValidating();\r\n                if (resolverRef.current) {\r\n                    const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    error = get(errors, name);\r\n                    if (isCheckBoxInput(target) &&\r\n                        !error &&\r\n                        resolverRef.current) {\r\n                        const parentNodeName = getFieldArrayParentName(name);\r\n                        const currentError = get(errors, parentNodeName, {});\r\n                        currentError.type &&\r\n                            currentError.message &&\r\n                            (error = currentError);\r\n                        if (parentNodeName &&\r\n                            (currentError ||\r\n                                get(formStateRef.current.errors, parentNodeName))) {\r\n                            name = parentNodeName;\r\n                        }\r\n                    }\r\n                    isValid = isEmptyObject(errors);\r\n                    previousFormIsValid !== isValid && (shouldRender = true);\r\n                }\r\n                else {\r\n                    error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\r\n                }\r\n                !isBlurEvent && renderWatchedInputs(name);\r\n                shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\r\n            }\r\n        };\r\n    function setFieldArrayDefaultValues(data) {\r\n        if (!shouldUnregister) {\r\n            let copy = cloneObject(data);\r\n            for (const value of fieldArrayNamesRef.current) {\r\n                if (isKey(value) && !copy[value]) {\r\n                    copy = Object.assign(Object.assign({}, copy), { [value]: [] });\r\n                }\r\n            }\r\n            return copy;\r\n        }\r\n        return data;\r\n    }\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\r\n        }\r\n        if (Array.isArray(payload)) {\r\n            const data = {};\r\n            for (const name of payload) {\r\n                set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            }\r\n            return data;\r\n        }\r\n        return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister));\r\n    }\r\n    const validateResolver = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (values = {}) => {\r\n        const newDefaultValues = isEmptyObject(fieldsRef.current)\r\n            ? defaultValuesRef.current\r\n            : {};\r\n        const { errors } = (await resolverRef.current(Object.assign(Object.assign(Object.assign({}, newDefaultValues), getValues()), values), contextRef.current, isValidateAllFieldCriteria)) || {};\r\n        const isValid = isEmptyObject(errors);\r\n        formStateRef.current.isValid !== isValid &&\r\n            updateFormState({\r\n                isValid,\r\n            });\r\n    }, [isValidateAllFieldCriteria]);\r\n    const removeFieldEventListener = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, forceDelete) => {\r\n        findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);\r\n        if (shouldUnregister) {\r\n            unset(validFieldsRef.current, field.ref.name);\r\n            unset(fieldsWithValidationRef.current, field.ref.name);\r\n        }\r\n    }, [shouldUnregister]);\r\n    const updateWatchedValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name) => {\r\n        if (isWatchAllRef.current) {\r\n            updateFormState();\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    updateFormState();\r\n                    break;\r\n                }\r\n            }\r\n            renderWatchedInputs(name);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, forceDelete) => {\r\n        if (field) {\r\n            removeFieldEventListener(field, forceDelete);\r\n            if (shouldUnregister && !compact(field.options || []).length) {\r\n                unset(formStateRef.current.errors, field.ref.name);\r\n                set(formStateRef.current.dirtyFields, field.ref.name, true);\r\n                updateFormState({\r\n                    isDirty: isFormDirty(),\r\n                });\r\n                readFormStateRef.current.isValid &&\r\n                    resolverRef.current &&\r\n                    validateResolver();\r\n                updateWatchedValue(field.ref.name);\r\n            }\r\n        }\r\n    }, [validateResolver, removeFieldEventListener]);\r\n    function clearErrors(name) {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => fieldsRef.current[inputName] && isKey(inputName)\r\n                ? delete formStateRef.current.errors[inputName]\r\n                : unset(formStateRef.current.errors, inputName));\r\n        updateFormState({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    }\r\n    function setError(name, error) {\r\n        const ref = (fieldsRef.current[name] || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        updateFormState({\r\n            isValid: false,\r\n        });\r\n        error.shouldFocus && ref && ref.focus && ref.focus();\r\n    }\r\n    const watchInternal = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((fieldNames, defaultValue, watchId) => {\r\n        const watchFields = watchId\r\n            ? useWatchFieldsRef.current[watchId]\r\n            : watchFieldsRef.current;\r\n        let fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, false, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            const parentNodeName = getFieldArrayParentName(fieldNames) || fieldNames;\r\n            if (fieldArrayNamesRef.current.has(parentNodeName)) {\r\n                fieldValues = Object.assign(Object.assign({}, fieldArrayValuesRef.current), fieldValues);\r\n            }\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(get(defaultValuesRef.current, fieldNames))\r\n                ? defaultValue\r\n                : get(defaultValuesRef.current, fieldNames), true);\r\n        }\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        if (Array.isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = isUndefined(watchId);\r\n        return transformToNestObject((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            combinedDefaultValues);\r\n    }, []);\r\n    function watch(fieldNames, defaultValue) {\r\n        return watchInternal(fieldNames, defaultValue);\r\n    }\r\n    function unregister(name) {\r\n        for (const fieldName of Array.isArray(name) ? name : [name]) {\r\n            removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\r\n        }\r\n    }\r\n    function registerFieldRef(ref, options = {}) {\r\n        if (false) {}\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, options);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const compareRef = (currentRef) => isWeb && (!isHTMLElement(ref) || currentRef === ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let defaultValue;\r\n        if (field &&\r\n            (isRadioOrCheckbox\r\n                ? Array.isArray(field.options) &&\r\n                    compact(field.options).find((option) => {\r\n                        return value === option.ref.value && compareRef(option.ref);\r\n                    })\r\n                : compareRef(field.ref))) {\r\n            fields[name] = Object.assign(Object.assign({}, field), options);\r\n            return;\r\n        }\r\n        if (type) {\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...compact((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                        },\r\n                    ], ref: { type, name } }, options) : Object.assign({}, fieldRefAndValidationOptions);\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\r\n        if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\r\n            defaultValue = get(isEmptyUnmountFields\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if (!isEmptyObject(options)) {\r\n            set(fieldsWithValidationRef.current, name, true);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then((error) => {\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    isEmptyObject(error)\r\n                        ? set(validFieldsRef.current, name, true)\r\n                        : unset(validFieldsRef.current, name);\r\n                    previousFormIsValid !== isEmptyObject(error) && updateFormState();\r\n                });\r\n            }\r\n        }\r\n        if (shouldUnregister && !(isFieldArray && isEmptyDefaultValue)) {\r\n            !isFieldArray && unset(formStateRef.current.dirtyFields, name);\r\n        }\r\n        if (type) {\r\n            attachEventListeners(isRadioOrCheckbox && field.options\r\n                ? field.options[field.options.length - 1]\r\n                : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\r\n        }\r\n    }\r\n    function register(refOrRegisterOptions, options) {\r\n        if (!isWindowUndefined) {\r\n            if (isString(refOrRegisterOptions)) {\r\n                registerFieldRef({ name: refOrRegisterOptions }, options);\r\n            }\r\n            else if (isObject(refOrRegisterOptions) &&\r\n                'name' in refOrRegisterOptions) {\r\n                registerFieldRef(refOrRegisterOptions, options);\r\n            }\r\n            else {\r\n                return (ref) => ref && registerFieldRef(ref, refOrRegisterOptions);\r\n            }\r\n        }\r\n    }\r\n    const handleSubmit = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((onValid, onInvalid) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, true));\r\n        readFormStateRef.current.isSubmitting &&\r\n            updateFormState({\r\n                isSubmitting: true,\r\n            });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\r\n                formStateRef.current.errors = fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fieldsRef.current)) {\r\n                    if (field) {\r\n                        const { name } = field.ref;\r\n                        const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            unset(validFieldsRef.current, name);\r\n                        }\r\n                        else if (get(fieldsWithValidationRef.current, name)) {\r\n                            unset(formStateRef.current.errors, name);\r\n                            set(validFieldsRef.current, name, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => name in fieldsRef.current)) {\r\n                updateFormState({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitting = false;\r\n            updateFormState({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria]);\r\n    const resetRefs = ({ errors, isDirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        if (!isValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        fieldArrayDefaultValuesRef.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        updateFormState({\r\n            submitCount: submitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: isDirty ? formStateRef.current.isDirty : false,\r\n            isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: isValid ? formStateRef.current.isValid : false,\r\n            dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\r\n            touched: touched ? formStateRef.current.touched : {},\r\n            errors: errors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        fieldsRef.current = {};\r\n        defaultValuesRef.current = Object.assign({}, (values || defaultValuesRef.current));\r\n        values && renderWatchedInputs('');\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        shallowFieldsStateRef.current = shouldUnregister\r\n            ? {}\r\n            : cloneObject(values || defaultValuesRef.current);\r\n        resetRefs(omitResetState);\r\n    };\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        resolver && readFormStateRef.current.isValid && validateResolver();\r\n        observerRef.current =\r\n            observerRef.current || !isWeb\r\n                ? observerRef.current\r\n                : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\r\n    }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => () => {\r\n        observerRef.current && observerRef.current.disconnect();\r\n        isUnMount.current = true;\r\n        if (false) {}\r\n        Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, []);\r\n    if (!resolver && readFormStateRef.current.isValid) {\r\n        formState.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n    }\r\n    const commonProps = {\r\n        trigger,\r\n        setValue: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(setValue, [setInternalValue, trigger]),\r\n        getValues: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(getValues, []),\r\n        register: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(register, [defaultValuesRef.current]),\r\n        unregister: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(unregister, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (false) {}\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(() => (Object.assign({ isFormDirty,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        updateFormState,\r\n        removeFieldEventListener,\r\n        watchInternal, mode: modeRef.current, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnChange,\r\n        }, validateResolver: resolver ? validateResolver : undefined, fieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        useWatchFieldsRef,\r\n        useWatchRenderFunctionsRef,\r\n        fieldArrayDefaultValuesRef,\r\n        validFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        readFormStateRef,\r\n        formStateRef,\r\n        defaultValuesRef,\r\n        shallowFieldsStateRef,\r\n        fieldArrayValuesRef }, commonProps)), [\r\n        defaultValuesRef.current,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        removeFieldEventListener,\r\n        watchInternal,\r\n    ]);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(reset, []), clearErrors: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(clearErrors, []), setError: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(setError, []), errors: formState.errors }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"])(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormContext);\r\nconst FormProvider = (_a) => {\r\n    var { children } = _a, props = __rest(_a, [\"children\"]);\r\n    return (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(FormContext.Provider, { value: Object.assign({}, props) }, children));\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value || undefined]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nvar fillBooleanArray = (value) => (Array.isArray(value) ? value : [value]).map((data) => {\r\n    if (isObject(data)) {\r\n        const object = {};\r\n        for (const key in data) {\r\n            object[key] = true;\r\n        }\r\n        return object;\r\n    }\r\n    return true;\r\n});\n\nconst mapIds = (values = [], keyName, skipWarn) => {\r\n    if (false) {}\r\n    return values.map((value) => (Object.assign({ [keyName]: value[keyName] || generateId() }, value)));\r\n};\r\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    if (false) {}\r\n    const focusIndexRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(-1);\r\n    const isUnMount = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const { isFormDirty, updateWatchedValue, resetFieldArrayFunctionRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, removeFieldEventListener, formStateRef, shallowFieldsStateRef, updateFormState, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, validateResolver, getValues, shouldUnregister, fieldArrayValuesRef, } = control || methods.control;\r\n    const getDefaultValues = (values) => get(shouldUnregister ? values : shallowFieldsStateRef.current, name, []);\r\n    const fieldArrayParentName = getFieldArrayParentName(name);\r\n    const memoizedDefaultValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])([\r\n        ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\r\n            ? getDefaultValues(fieldArrayDefaultValuesRef.current)\r\n            : getDefaultValues(defaultValuesRef.current)),\r\n    ]);\r\n    const [fields, setFields] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(mapIds(memoizedDefaultValues.current, keyName));\r\n    set(fieldArrayValuesRef.current, name, fields);\r\n    const omitKey = (fields) => fields.map((_a = {}) => {\r\n        var _b = keyName, omitted = _a[_b], rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\r\n        return rest;\r\n    });\r\n    fieldArrayNamesRef.current.add(name);\r\n    const getFieldArrayValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(() => get(fieldArrayValuesRef.current, name, []), [name]);\r\n    const getCurrentFieldsValues = () => mapIds(get(getValues(), name, getFieldArrayValue()).map((item, index) => (Object.assign(Object.assign({}, getFieldArrayValue()[index]), item))), keyName, true);\r\n    fieldArrayNamesRef.current.add(name);\r\n    if (fieldArrayParentName &&\r\n        !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\r\n        set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, cloneObject(get(defaultValuesRef.current, fieldArrayParentName)));\r\n    }\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setFields(fieldsValues);\r\n        set(fieldArrayValuesRef.current, name, fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateResolver) {\r\n            const values = getValues();\r\n            set(values, name, fieldsValues);\r\n            validateResolver(values);\r\n        }\r\n    };\r\n    const resetFields = () => {\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name)) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n                delete fieldsRef.current[key];\r\n            }\r\n        }\r\n    };\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => {\r\n        if (updatedFieldArrayValues) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n        }\r\n    };\r\n    const batchStateUpdate = (method, args, updatedFieldValues, updatedFormValues = [], shouldSet = true, shouldUpdateValid = false) => {\r\n        if (get(shallowFieldsStateRef.current, name)) {\r\n            const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(shallowFieldsStateRef.current, name, output);\r\n        }\r\n        if (get(fieldArrayDefaultValuesRef.current, name)) {\r\n            const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(formStateRef.current.touched, name)) {\r\n            const output = method(get(formStateRef.current.touched, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touched, name, output);\r\n            cleanup(formStateRef.current.touched);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFormValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (shouldUpdateValid &&\r\n            readFormStateRef.current.isValid &&\r\n            !validateResolver) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        if (!isUnMount.current && readFormStateRef.current.isDirty) {\r\n            updateFormState({\r\n                isDirty: isFormDirty(name, omitKey(updatedFormValues)),\r\n            });\r\n        }\r\n    };\r\n    const append = (value, shouldFocus = true) => {\r\n        const appendValue = Array.isArray(value) ? value : [value];\r\n        const updateFormValues = [\r\n            ...getCurrentFieldsValues(),\r\n            ...mapIds(appendValue, keyName),\r\n        ];\r\n        setFieldAndValidState(updateFormValues);\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            updateDirtyFieldsWithDefaultValues(updateFormValues);\r\n            updateFormState({\r\n                isDirty: true,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            });\r\n        }\r\n        !shouldUnregister &&\r\n            set(shallowFieldsStateRef.current, name, [\r\n                ...(get(shallowFieldsStateRef.current, name) || []),\r\n                ...cloneObject(appendValue),\r\n            ]);\r\n        focusIndexRef.current = shouldFocus\r\n            ? get(fieldArrayValuesRef.current, name).length - 1\r\n            : -1;\r\n    };\r\n    const prepend$1 = (value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(prepend, {\r\n            argA: emptyArray,\r\n            argC: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues);\r\n        focusIndexRef.current = shouldFocus ? 0 : -1;\r\n    };\r\n    const remove = (index) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldValues = removeArrayAt(fieldValues, index);\r\n        setFieldAndValidState(updatedFieldValues);\r\n        resetFields();\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n            argC: index,\r\n        }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\r\n    };\r\n    const insert$1 = (index, value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: emptyArray,\r\n            argC: index,\r\n            argD: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues, insert(fieldValues, index));\r\n        focusIndexRef.current = shouldFocus ? index : -1;\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n            argC: indexA,\r\n            argD: indexB,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n            argC: from,\r\n            argD: to,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (false) {}\r\n        const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\r\n        if (defaultValues && fields.length < defaultValues.length) {\r\n            set(fieldArrayDefaultValuesRef.current, name, defaultValues.slice(1));\r\n        }\r\n        updateWatchedValue(name);\r\n        if (focusIndexRef.current > -1) {\r\n            for (const key in fieldsRef.current) {\r\n                const field = fieldsRef.current[key];\r\n                if (key.startsWith(`${name}[${focusIndexRef.current}]`) &&\r\n                    field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        focusIndexRef.current = -1;\r\n    }, [fields, name]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        if (!getFieldArrayParentName(name)) {\r\n            resetFunctions[name] = (data) => {\r\n                resetFields();\r\n                !data && unset(fieldArrayDefaultValuesRef.current, name);\r\n                unset(shallowFieldsStateRef.current, name);\r\n                memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\r\n                if (!isUnMount.current) {\r\n                    setFields(mapIds(memoizedDefaultValues.current, keyName));\r\n                }\r\n            };\r\n        }\r\n        return () => {\r\n            isUnMount.current = true;\r\n            shouldUnregister && remove();\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            unset(fieldArrayValuesRef.current, name);\r\n            fieldArrayNames.delete(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(swap, [name]),\r\n        move: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(move, [name]),\r\n        prepend: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(prepend$1, [name]),\r\n        append: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(append, [name]),\r\n        remove: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(remove, [name]),\r\n        insert: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(insert$1, [name]),\r\n        fields: compact(fields),\r\n    };\r\n};\n\nvar getInputValue = (event) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nfunction useController({ name, rules, defaultValue, control, onFocus, }) {\r\n    const methods = useFormContext();\r\n    if (false) {}\r\n    const { defaultValuesRef, setValue, register, unregister, trigger, mode, reValidateMode: { isReValidateOnBlur, isReValidateOnChange }, formState, formStateRef: { current: { isSubmitted, touched, errors }, }, updateFormState, readFormStateRef, fieldsRef, fieldArrayNamesRef, shallowFieldsStateRef, } = control || methods.control;\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\r\n        ? get(shallowFieldsStateRef.current, name)\r\n        : isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue;\r\n    const [value, setInputStateValue] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(getInitialValue());\r\n    const valueRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(value);\r\n    const ref = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({\r\n        focus: () => null,\r\n    });\r\n    const onFocusRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(onFocus ||\r\n        (() => {\r\n            if (isFunction(ref.current.focus)) {\r\n                ref.current.focus();\r\n            }\r\n            if (false) {}\r\n        }));\r\n    const shouldValidate = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((isBlurEvent) => !skipValidation(Object.assign({ isBlurEvent,\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted, isTouched: !!get(touched, name) }, mode)), [\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted,\r\n        touched,\r\n        name,\r\n        mode,\r\n    ]);\r\n    const commonTask = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(([event]) => {\r\n        const data = getInputValue(event);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    }, []);\r\n    const registerField = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((shouldUpdateValue) => {\r\n        if (false) {}\r\n        if (fieldsRef.current[name]) {\r\n            fieldsRef.current[name] = Object.assign({ ref: fieldsRef.current[name].ref }, rules);\r\n        }\r\n        else {\r\n            register(Object.defineProperties({\r\n                name,\r\n                focus: onFocusRef.current,\r\n            }, {\r\n                value: {\r\n                    set(data) {\r\n                        setInputStateValue(data);\r\n                        valueRef.current = data;\r\n                    },\r\n                    get() {\r\n                        return valueRef.current;\r\n                    },\r\n                },\r\n            }), rules);\r\n            shouldUpdateValue = isUndefined(get(defaultValuesRef.current, name));\r\n        }\r\n        shouldUpdateValue &&\r\n            isNotFieldArray &&\r\n            setInputStateValue(getInitialValue());\r\n    }, [rules, name, register]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => () => unregister(name), [name]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (false) {}\r\n        registerField();\r\n    }, [registerField]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        !fieldsRef.current[name] && registerField(true);\r\n    });\r\n    const onBlur = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(() => {\r\n        if (readFormStateRef.current.touched && !get(touched, name)) {\r\n            set(touched, name, true);\r\n            updateFormState({\r\n                touched,\r\n            });\r\n        }\r\n        shouldValidate(true) && trigger(name);\r\n    }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);\r\n    const onChange = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((...event) => setValue(name, commonTask(event), {\r\n        shouldValidate: shouldValidate(),\r\n        shouldDirty: true,\r\n    }), [setValue, name, shouldValidate]);\r\n    return {\r\n        field: {\r\n            onChange,\r\n            onBlur,\r\n            name,\r\n            value,\r\n            ref,\r\n        },\r\n        meta: Object.defineProperties({\r\n            invalid: !!get(errors, name),\r\n        }, {\r\n            isDirty: {\r\n                get() {\r\n                    return !!get(formState.dirtyFields, name);\r\n                },\r\n            },\r\n            isTouched: {\r\n                get() {\r\n                    return !!get(formState.touched, name);\r\n                },\r\n            },\r\n        }),\r\n    };\r\n}\n\nfunction useWatch({ control, name, defaultValue, }) {\r\n    const methods = useFormContext();\r\n    if (false) {}\r\n    const { useWatchFieldsRef, useWatchRenderFunctionsRef, watchInternal, defaultValuesRef, } = control || methods.control;\r\n    const updateValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])()[1];\r\n    const idRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\r\n    const defaultValueRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(defaultValue);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (false) {}\r\n        const id = (idRef.current = generateId());\r\n        const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\r\n        const watchFieldsHook = useWatchFieldsRef.current;\r\n        watchFieldsHook[id] = new Set();\r\n        watchFieldsHookRender[id] = () => updateValue({});\r\n        watchInternal(name, defaultValueRef.current, id);\r\n        return () => {\r\n            delete watchFieldsHook[id];\r\n            delete watchFieldsHookRender[id];\r\n        };\r\n    }, [\r\n        name,\r\n        useWatchRenderFunctionsRef,\r\n        useWatchFieldsRef,\r\n        watchInternal,\r\n        defaultValueRef,\r\n    ]);\r\n    return idRef.current\r\n        ? watchInternal(name, defaultValueRef.current, idRef.current)\r\n        : isUndefined(defaultValue)\r\n            ? isString(name)\r\n                ? get(defaultValuesRef.current, name)\r\n                : Array.isArray(name)\r\n                    ? name.reduce((previous, inputName) => (Object.assign(Object.assign({}, previous), { [inputName]: get(defaultValuesRef.current, inputName) })), {})\r\n                    : defaultValuesRef.current\r\n            : defaultValue;\r\n}\n\nconst Controller = (props) => {\r\n    const { rules, as, render, defaultValue, control, onFocus } = props, rest = __rest(props, [\"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const { field, meta } = useController(props);\r\n    const componentProps = Object.assign(Object.assign({}, rest), field);\r\n    return as\r\n        ? Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(as)\r\n            ? Object(react__WEBPACK_IMPORTED_MODULE_0__[\"cloneElement\"])(as, componentProps)\r\n            : Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(as, componentProps)\r\n        : render\r\n            ? render(field, meta)\r\n            : null;\r\n};\n\n\n//# sourceMappingURL=index.esm.js.map\n\n\n/***/ }),\n\n/***/ \"rePB\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return _defineProperty; });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:\\Users\\AJ\\Downloads\\themeforest-tpjiC5zC-edemy-react-next-education-lms-template\\edemy-react-next-online-courses-education-template\\edemy-react-next\\node_modules\\react-hook-form\\dist\\index.esm.js","C:\\Users\\AJ\\Downloads\\themeforest-tpjiC5zC-edemy-react-next-education-lms-template\\edemy-react-next-online-courses-education-template\\edemy-react-next\\node_modules\\@babel\\runtime\\helpers\\esm\\defineProperty.js"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkJ;;AAElJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,WAAW,QAAQ;;AAEnB;;AAEA;;AAEA;;AAEA,wDAAwD,OAAO;;AAE/D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO,QAAQ,EAAE;AACxC,oBAAoB;AACpB;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO,kBAAkB,gDAAgD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY,OAAO,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4DAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,iFAAiF;AACjF;AACA;AACA,wDAAwD;AACxD,kDAAkD;AAClD,0EAA0E,wBAAwB,cAAc;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,0DAA0D;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,4DAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,kBAAkB,sCAAsC,+DAA+D,KAAK,0BAA0B,GAAG;;AAE7L,iEAAiE,YAAY,QAAQ,yEAAyE;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe;AACf;AACA;AACA,yCAAyC;AACzC,uEAAuE;AACvE,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA,yCAAyC;AACzC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2HAA2H;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+DAA+D,WAAW;AAC1E;;AAEA,qDAAqD,OAAO;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,kBAAkB,kHAAkH,mEAAmE,KAAK;AAC5M,sBAAsB,oDAAM,GAAG;AAC/B,uCAAuC,oDAAM,GAAG;AAChD,gCAAgC,oDAAM,GAAG;AACzC,2BAA2B,oDAAM;AACjC,8BAA8B,oDAAM,GAAG;AACvC,uCAAuC,oDAAM,GAAG;AAChD,oCAAoC,oDAAM,GAAG;AAC7C,2BAA2B,oDAAM,GAAG;AACpC,6BAA6B,oDAAM;AACnC,sBAAsB,oDAAM;AAC5B,0BAA0B,oDAAM;AAChC,4BAA4B,oDAAM;AAClC,kCAAkC,oDAAM,GAAG;AAC3C,uCAAuC,oDAAM,GAAG;AAChD,uBAAuB,oDAAM;AAC7B,wBAAwB,oDAAM;AAC9B,+BAA+B,oDAAM;AACrC,oBAAoB,oDAAM;AAC1B,WAAW,wBAAwB;AACnC;AACA,sCAAsC,sDAAQ;AAC9C;AACA;AACA,uBAAuB;AACvB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,kBAAkB;AAClB,KAAK;AACL,6BAA6B,oDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,oDAAM;AAC/B,wBAAwB,oDAAM;AAC9B,WAAW,kEAAkE,GAAG,oDAAM;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAW,YAAY;AACnD;AACA,iEAAiE;AACjE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,oCAAoC,yDAAW,+CAA+C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,kCAAkC,qBAAqB,KAAK,KAAK,sBAAsB;AAC/J;AACA,KAAK;AACL,0BAA0B,yDAAW;AACrC,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB,yDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC,yDAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,yDAAW;AACzC,YAAY,KAAqC,EAAE,EAK1C;AACT;AACA;AACA;AACA,KAAK;AACL,8CAA8C,yDAAW;AACzD,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mGAAmG;AACnG;AACA;AACA,KAAK;AACL,oBAAoB,yDAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL,8BAA8B,yDAAW,gBAAgB,8BAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6BAA6B,yDAAW;AACxC;AACA;AACA,yGAAyG;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0EAA0E,iBAAiB,gBAAgB;AAC3G,qBAAqB;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA,6IAA6I;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW,wCAAwC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU,cAAc;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAW,mBAAmB;AAC3D;AACA;AACA;AACA,eAAe,SAAS,0EAA0E;AAClG;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,qCAAqC,yDAAW;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,yDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2CAA2C,yDAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,SAAS;AACT;AACA;AACA,kDAAkD;AAClD,6EAA6E,WAAW,MAAM;AAC9F;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,yDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,cAAc,mFAAmF,MAAM;AAC/L;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,YAAY,KAAqC,EAAE,EAU1C;AACT,eAAe,oBAAoB;AACnC,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,yBAAyB;AACzB,6BAA6B,aAAa,EAAE,6BAA6B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6BAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,wBAAwB,4EAA4E;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,gEAAgE;AAChE,6DAA6D;AAC7D;AACA;AACA,SAAS;AACT;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,uDAAS;AACb;AACA;AACA,YAAY,KAAqC,EAAE,EAE1C;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;AAC7B,mBAAmB,yDAAW;AAC9B,kBAAkB,yDAAW;AAC7B,oBAAoB,yDAAW;AAC/B;AACA;AACA;AACA,wBAAwB,KAAqC,EAAE,EAI1C;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,oBAAoB,qDAAO,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,6BAA6B,yDAAW,0BAA0B,yDAAW,6BAA6B,yDAAW,0CAA0C;AAC/J;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,2DAAa;AACjC;AACA,6BAA6B,wDAAU;AACvC;AACA,SAAS,WAAW;AACpB,YAAY,2DAAa,wBAAwB,wBAAwB,UAAU;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,QAAQ,KAAqC,EAAE,EAe1C;AACL,iDAAiD,4CAA4C;AAC7F;AACA,wBAAwB,iCAAiC;AACzD;AACA,QAAQ,KAAqC,EAAE,EAI1C;AACL,0BAA0B,oDAAM;AAChC,sBAAsB,oDAAM;AAC5B,WAAW,2VAA2V;AACtW;AACA;AACA,kCAAkC,oDAAM;AACxC;AACA;AACA;AACA;AACA,gCAAgC,sDAAQ;AACxC;AACA,mDAAmD;AACnD;AACA;AACA,KAAK;AACL;AACA,+BAA+B,yDAAW;AAC1C,iJAAiJ;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI,uDAAS;AACb,YAAY,KAAqC,EAAE,EAI1C;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK,GAAG,sBAAsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,yDAAW;AACzB,cAAc,yDAAW;AACzB,iBAAiB,yDAAW;AAC5B,gBAAgB,yDAAW;AAC3B,gBAAgB,yDAAW;AAC3B,gBAAgB,yDAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,+CAA+C;AACvE;AACA,QAAQ,KAAqC,EAAE,EAI1C;AACL,WAAW,mFAAmF,2CAA2C,4BAA4B,WAAW,+BAA+B,GAAG,4FAA4F;AAC9S;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sDAAQ;AAChD,qBAAqB,oDAAM;AAC3B,gBAAgB,oDAAM;AACtB;AACA,KAAK;AACL,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,KAAqC,EAAE,EAI1C;AACb,SAAS;AACT,2BAA2B,yDAAW,iDAAiD;AACvF;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAW;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,yDAAW;AACrC,YAAY,KAAqC,EAAE,EAI1C;AACT;AACA,qDAAqD,mCAAmC;AACxF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,uDAAS;AACb,IAAI,uDAAS;AACb,YAAY,KAAqC,EAAE,EAO1C;AACT;AACA,KAAK;AACL,IAAI,uDAAS;AACb;AACA,KAAK;AACL,mBAAmB,yDAAW;AAC9B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL,qBAAqB,yDAAW;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;;AAEA,mBAAmB,+BAA+B;AAClD;AACA,QAAQ,KAAqC,EAAE,EAI1C;AACL,WAAW,kFAAkF;AAC7F,wBAAwB,sDAAQ;AAChC,kBAAkB,oDAAM;AACxB,4BAA4B,oDAAM;AAClC,IAAI,uDAAS;AACb,YAAY,KAAqC,EAAE,EAI1C;AACT;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,cAAc,wDAAwD,MAAM;AACtK;AACA;AACA;;AAEA;AACA,WAAW,oDAAoD;AAC/D,WAAW,cAAc;AACzB,yDAAyD;AACzD;AACA,UAAU,4DAAc;AACxB,cAAc,0DAAY;AAC1B,cAAc,2DAAa;AAC3B;AACA;AACA;AACA;;AAE+I;AAC/I;;;;;;;;;ACv4DA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA,C","file":"x","sourcesContent":["import { isValidElement, useRef, useState, useCallback, useEffect, useMemo, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ ref }, shouldAttachChangeEvent, handleChange) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar stringToPath = (input) => compact(input\r\n    .replace(/[\"|']/g, '')\r\n    .replace(/\\[/g, '.')\r\n    .replace(/\\]/g, '')\r\n    .split('.'));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data, value = {}) => {\r\n    for (const key in data) {\r\n        !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\r\n    }\r\n    return value;\r\n};\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj = {}, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus && isUndefined(field.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || value === ''\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled, shouldKeepRawValue) {\r\n    const field = fieldsRef.current[name];\r\n    if (field) {\r\n        const { ref: { value, disabled }, ref, valueAsNumber, valueAsDate, setValueAs, } = field;\r\n        if (disabled && excludeDisabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field.options).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field.options).value;\r\n        }\r\n        return shouldKeepRawValue\r\n            ? value\r\n            : valueAsNumber\r\n                ? value === ''\r\n                    ? NaN\r\n                    : +value\r\n                : valueAsDate\r\n                    ? ref.valueAsDate\r\n                    : setValueAs\r\n                        ? setValueAs(value)\r\n                        : value;\r\n    }\r\n    if (shallowFieldsStateRef) {\r\n        return get(shallowFieldsStateRef.current, name);\r\n    }\r\n}\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\r\n    const { ref, ref: { name }, } = field;\r\n    const fieldRef = fieldsRef.current[name];\r\n    if (!shouldUnregister) {\r\n        const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\r\n    }\r\n    if (!ref.type || !fieldRef) {\r\n        delete fieldsRef.current[name];\r\n        return;\r\n    }\r\n    if (isRadioInput(ref) || isCheckBoxInput(ref)) {\r\n        if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\r\n            compact(fieldRef.options).forEach((option = {}, index) => {\r\n                if ((isDetached(option.ref) && isSameRef(option, option.ref)) ||\r\n                    forceDelete) {\r\n                    removeAllEventListeners(option.ref, handleChange);\r\n                    unset(fieldRef.options, `[${index}]`);\r\n                }\r\n            });\r\n            if (fieldRef.options && !compact(fieldRef.options).length) {\r\n                delete fieldsRef.current[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fieldsRef.current[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        delete fieldsRef.current[name];\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!isValidElement(object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) => {\r\n    const output = {};\r\n    for (const name in fieldsRef.current) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : Array.isArray(search) && search.find((data) => name.startsWith(data)))) {\r\n            output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\r\n        }\r\n    }\r\n    return shouldUnregister\r\n        ? transformToNestObject(output)\r\n        : deepMerge(shallowFieldsState, transformToNestObject(output));\r\n};\n\nvar isErrorStateChanged = ({ errors, name, error, validFields, fieldsWithValidation, }) => {\r\n    const isValid = isUndefined(error);\r\n    const previousError = get(errors, name);\r\n    return ((isValid && !!previousError) ||\r\n        (!isValid && !deepEqual(previousError, error, true)) ||\r\n        (isValid && get(fieldsWithValidation, name) && !get(validFields, name)));\r\n};\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || isValidElement(value);\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { value }, options, required, maxLength, minLength, min, max, pattern, validate, }, shallowFieldsStateRef) => {\r\n    const name = ref.name;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = value === '';\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox\r\n                    ? ((fieldsRef.current[name].options || [])[0] || {}).ref\r\n                    : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && value !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(value)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            value.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            value.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef, false, true);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst getPath = (rootPath, values, paths = []) => {\r\n    for (const property in values) {\r\n        const rootName = (rootPath +\r\n            (isObject(values)\r\n                ? `.${property}`\r\n                : `[${property}]`));\r\n        isPrimitive(values[property])\r\n            ? paths.push(rootName)\r\n            : getPath(rootName, values[property], paths);\r\n    }\r\n    return paths;\r\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value = undefined;\r\n    watchFields.add(fieldName);\r\n    if (!isEmptyObject(fieldValues)) {\r\n        value = get(fieldValues, fieldName);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            getPath(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\r\n    const observer = new MutationObserver(() => {\r\n        for (const field of Object.values(fieldsRef.current)) {\r\n            if (field && field.options) {\r\n                for (const option of field.options) {\r\n                    if (option && option.ref && isDetached(option.ref)) {\r\n                        removeFieldEventListenerAndRef(field);\r\n                    }\r\n                }\r\n            }\r\n            else if (field && isDetached(field.ref)) {\r\n                removeFieldEventListenerAndRef(field);\r\n            }\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar isWeb = typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n\nfunction cloneObject(data) {\r\n    var _a;\r\n    let copy;\r\n    if (isPrimitive(data) ||\r\n        (isWeb && (data instanceof File || isHTMLElement(data)))) {\r\n        return data;\r\n    }\r\n    if (!['Set', 'Map', 'Object', 'Date', 'Array'].includes((_a = data.constructor) === null || _a === void 0 ? void 0 : _a.name)) {\r\n        return data;\r\n    }\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n        return copy;\r\n    }\r\n    if (data instanceof Set) {\r\n        copy = new Set();\r\n        for (const item of data) {\r\n            copy.add(item);\r\n        }\r\n        return copy;\r\n    }\r\n    if (data instanceof Map) {\r\n        copy = new Map();\r\n        for (const key of data.keys()) {\r\n            copy.set(key, cloneObject(data.get(key)));\r\n        }\r\n        return copy;\r\n    }\r\n    copy = Array.isArray(data) ? [] : {};\r\n    for (const key in data) {\r\n        copy[key] = cloneObject(data[key]);\r\n    }\r\n    return copy;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = true, criteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const fieldArrayDefaultValuesRef = useRef({});\r\n    const fieldArrayValuesRef = useRef({});\r\n    const watchFieldsRef = useRef(new Set());\r\n    const useWatchFieldsRef = useRef({});\r\n    const useWatchRenderFunctionsRef = useRef({});\r\n    const fieldsWithValidationRef = useRef({});\r\n    const validFieldsRef = useRef({});\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const handleChangeRef = useRef();\r\n    const shallowFieldsStateRef = useRef({});\r\n    const resetFieldArrayFunctionRef = useRef({});\r\n    const contextRef = useRef(context);\r\n    const resolverRef = useRef(resolver);\r\n    const fieldArrayNamesRef = useRef(new Set());\r\n    const modeRef = useRef(modeChecker(mode));\r\n    const { isOnSubmit, isOnTouch } = modeRef.current;\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touched: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touched: !isProxyEnabled || isOnTouch,\r\n        isValidating: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const formStateRef = useRef(formState);\r\n    const observerRef = useRef();\r\n    const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = useRef(modeChecker(reValidateMode)).current;\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    formStateRef.current = formState;\r\n    shallowFieldsStateRef.current = shouldUnregister\r\n        ? {}\r\n        : isEmptyObject(shallowFieldsStateRef.current)\r\n            ? cloneObject(defaultValues)\r\n            : shallowFieldsStateRef.current;\r\n    const updateFormState = useCallback((state = {}) => {\r\n        if (!isUnMount.current) {\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\r\n            setFormState(formStateRef.current);\r\n        }\r\n    }, []);\r\n    const updateIsValidating = () => readFormStateRef.current.isValidating &&\r\n        updateFormState({\r\n            isValidating: true,\r\n        });\r\n    const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false, state = {}, isValid) => {\r\n        let shouldReRender = shouldRender ||\r\n            isErrorStateChanged({\r\n                errors: formStateRef.current.errors,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state) ||\r\n            readFormStateRef.current.isValidating) {\r\n            updateFormState(Object.assign(Object.assign(Object.assign({}, state), (resolverRef.current ? { isValid: !!isValid } : {})), { isValidating: false }));\r\n        }\r\n    }, []);\r\n    const setFieldValue = useCallback((name, rawValue) => {\r\n        const { ref, options } = fieldsRef.current[name];\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref)) {\r\n            (options || []).forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref) && !isString(value)) {\r\n            ref.files = value;\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = Array.isArray(value)\r\n                    ? !!value.find((data) => data === checkboxRef.value)\r\n                    : value === checkboxRef.value))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, []);\r\n    const isFormDirty = useCallback((name, data) => {\r\n        if (readFormStateRef.current.isDirty) {\r\n            const formValues = getValues();\r\n            name && data && set(formValues, name, data);\r\n            return !deepEqual(formValues, defaultValuesRef.current);\r\n        }\r\n        return false;\r\n    }, []);\r\n    const updateAndGetDirtyState = useCallback((name, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            const state = {\r\n                isDirty: isFormDirty(),\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && updateFormState(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = useCallback(async (name, skipReRender) => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!fieldsRef.current[name]) {\r\n                console.warn('📋 Field is missing with `name` attribute: ', name);\r\n                return false;\r\n            }\r\n        }\r\n        const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = useCallback(async (names) => {\r\n        const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n        const previousFormIsValid = formStateRef.current.isValid;\r\n        if (Array.isArray(names)) {\r\n            const isInputsValid = names\r\n                .map((name) => {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(formStateRef.current.errors, name, error)\r\n                    : unset(formStateRef.current.errors, name);\r\n                return !error;\r\n            })\r\n                .every(Boolean);\r\n            updateFormState({\r\n                isValid: isEmptyObject(errors),\r\n                isValidating: false,\r\n            });\r\n            return isInputsValid;\r\n        }\r\n        else {\r\n            const error = get(errors, names);\r\n            shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\r\n            return !error;\r\n        }\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const trigger = useCallback(async (name) => {\r\n        const fields = name || Object.keys(fieldsRef.current);\r\n        updateIsValidating();\r\n        if (resolverRef.current) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (Array.isArray(fields)) {\r\n            !name && (formStateRef.current.errors = {});\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n            updateFormState({\r\n                isValidating: false,\r\n            });\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = useCallback((name, value, { shouldDirty, shouldValidate }) => {\r\n        const data = {};\r\n        set(data, name, value);\r\n        for (const fieldName of getPath(name, value)) {\r\n            if (fieldsRef.current[fieldName]) {\r\n                setFieldValue(fieldName, get(data, fieldName));\r\n                shouldDirty && updateAndGetDirtyState(fieldName);\r\n                shouldValidate && trigger(fieldName);\r\n            }\r\n        }\r\n    }, [trigger, setFieldValue, updateAndGetDirtyState]);\r\n    const setInternalValue = useCallback((name, value, config) => {\r\n        !shouldUnregister &&\r\n            !isPrimitive(value) &&\r\n            set(shallowFieldsStateRef.current, name, Array.isArray(value) ? [...value] : Object.assign({}, value));\r\n        if (fieldsRef.current[name]) {\r\n            setFieldValue(name, value);\r\n            config.shouldDirty && updateAndGetDirtyState(name);\r\n            config.shouldValidate && trigger(name);\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value, config);\r\n            if (fieldArrayNamesRef.current.has(name)) {\r\n                const parentName = getFieldArrayParentName(name) || name;\r\n                set(fieldArrayDefaultValuesRef.current, name, value);\r\n                resetFieldArrayFunctionRef.current[parentName]({\r\n                    [parentName]: get(fieldArrayDefaultValuesRef.current, parentName),\r\n                });\r\n                if ((readFormStateRef.current.isDirty ||\r\n                    readFormStateRef.current.dirtyFields) &&\r\n                    config.shouldDirty) {\r\n                    set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                    updateFormState({\r\n                        isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), { [name]: value }), defaultValuesRef.current),\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\r\n    }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const renderWatchedInputs = (name) => {\r\n        let found = true;\r\n        if (!isEmptyObject(useWatchFieldsRef.current)) {\r\n            for (const key in useWatchFieldsRef.current) {\r\n                if (!name ||\r\n                    !useWatchFieldsRef.current[key].size ||\r\n                    useWatchFieldsRef.current[key].has(name) ||\r\n                    useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\r\n                    useWatchRenderFunctionsRef.current[key]();\r\n                    found = false;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    };\r\n    function setValue(name, value, config) {\r\n        setInternalValue(name, value, config || {});\r\n        isFieldWatched(name) && updateFormState();\r\n        renderWatchedInputs(name);\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            let name = target.name;\r\n            const field = fieldsRef.current[name];\r\n            let error;\r\n            let isValid;\r\n            if (field) {\r\n                const isBlurEvent = type === EVENTS.BLUR;\r\n                const shouldSkipValidation = skipValidation(Object.assign({ isBlurEvent,\r\n                    isReValidateOnChange,\r\n                    isReValidateOnBlur, isTouched: !!get(formStateRef.current.touched, name), isSubmitted: formStateRef.current.isSubmitted }, modeRef.current));\r\n                let state = updateAndGetDirtyState(name, false);\r\n                let shouldRender = !isEmptyObject(state) ||\r\n                    (!isBlurEvent && isFieldWatched(name));\r\n                if (isBlurEvent &&\r\n                    !get(formStateRef.current.touched, name) &&\r\n                    readFormStateRef.current.touched) {\r\n                    set(formStateRef.current.touched, name, true);\r\n                    state = Object.assign(Object.assign({}, state), { touched: formStateRef.current.touched });\r\n                }\r\n                if (!shouldUnregister && isCheckBoxInput(target)) {\r\n                    set(shallowFieldsStateRef.current, name, getFieldValue(fieldsRef, name));\r\n                }\r\n                if (shouldSkipValidation) {\r\n                    !isBlurEvent && renderWatchedInputs(name);\r\n                    return ((!isEmptyObject(state) ||\r\n                        (shouldRender && isEmptyObject(state))) &&\r\n                        updateFormState(state));\r\n                }\r\n                updateIsValidating();\r\n                if (resolverRef.current) {\r\n                    const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    error = get(errors, name);\r\n                    if (isCheckBoxInput(target) &&\r\n                        !error &&\r\n                        resolverRef.current) {\r\n                        const parentNodeName = getFieldArrayParentName(name);\r\n                        const currentError = get(errors, parentNodeName, {});\r\n                        currentError.type &&\r\n                            currentError.message &&\r\n                            (error = currentError);\r\n                        if (parentNodeName &&\r\n                            (currentError ||\r\n                                get(formStateRef.current.errors, parentNodeName))) {\r\n                            name = parentNodeName;\r\n                        }\r\n                    }\r\n                    isValid = isEmptyObject(errors);\r\n                    previousFormIsValid !== isValid && (shouldRender = true);\r\n                }\r\n                else {\r\n                    error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\r\n                }\r\n                !isBlurEvent && renderWatchedInputs(name);\r\n                shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\r\n            }\r\n        };\r\n    function setFieldArrayDefaultValues(data) {\r\n        if (!shouldUnregister) {\r\n            let copy = cloneObject(data);\r\n            for (const value of fieldArrayNamesRef.current) {\r\n                if (isKey(value) && !copy[value]) {\r\n                    copy = Object.assign(Object.assign({}, copy), { [value]: [] });\r\n                }\r\n            }\r\n            return copy;\r\n        }\r\n        return data;\r\n    }\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\r\n        }\r\n        if (Array.isArray(payload)) {\r\n            const data = {};\r\n            for (const name of payload) {\r\n                set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            }\r\n            return data;\r\n        }\r\n        return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister));\r\n    }\r\n    const validateResolver = useCallback(async (values = {}) => {\r\n        const newDefaultValues = isEmptyObject(fieldsRef.current)\r\n            ? defaultValuesRef.current\r\n            : {};\r\n        const { errors } = (await resolverRef.current(Object.assign(Object.assign(Object.assign({}, newDefaultValues), getValues()), values), contextRef.current, isValidateAllFieldCriteria)) || {};\r\n        const isValid = isEmptyObject(errors);\r\n        formStateRef.current.isValid !== isValid &&\r\n            updateFormState({\r\n                isValid,\r\n            });\r\n    }, [isValidateAllFieldCriteria]);\r\n    const removeFieldEventListener = useCallback((field, forceDelete) => {\r\n        findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);\r\n        if (shouldUnregister) {\r\n            unset(validFieldsRef.current, field.ref.name);\r\n            unset(fieldsWithValidationRef.current, field.ref.name);\r\n        }\r\n    }, [shouldUnregister]);\r\n    const updateWatchedValue = useCallback((name) => {\r\n        if (isWatchAllRef.current) {\r\n            updateFormState();\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    updateFormState();\r\n                    break;\r\n                }\r\n            }\r\n            renderWatchedInputs(name);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (field) {\r\n            removeFieldEventListener(field, forceDelete);\r\n            if (shouldUnregister && !compact(field.options || []).length) {\r\n                unset(formStateRef.current.errors, field.ref.name);\r\n                set(formStateRef.current.dirtyFields, field.ref.name, true);\r\n                updateFormState({\r\n                    isDirty: isFormDirty(),\r\n                });\r\n                readFormStateRef.current.isValid &&\r\n                    resolverRef.current &&\r\n                    validateResolver();\r\n                updateWatchedValue(field.ref.name);\r\n            }\r\n        }\r\n    }, [validateResolver, removeFieldEventListener]);\r\n    function clearErrors(name) {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => fieldsRef.current[inputName] && isKey(inputName)\r\n                ? delete formStateRef.current.errors[inputName]\r\n                : unset(formStateRef.current.errors, inputName));\r\n        updateFormState({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    }\r\n    function setError(name, error) {\r\n        const ref = (fieldsRef.current[name] || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        updateFormState({\r\n            isValid: false,\r\n        });\r\n        error.shouldFocus && ref && ref.focus && ref.focus();\r\n    }\r\n    const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\r\n        const watchFields = watchId\r\n            ? useWatchFieldsRef.current[watchId]\r\n            : watchFieldsRef.current;\r\n        let fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, false, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            const parentNodeName = getFieldArrayParentName(fieldNames) || fieldNames;\r\n            if (fieldArrayNamesRef.current.has(parentNodeName)) {\r\n                fieldValues = Object.assign(Object.assign({}, fieldArrayValuesRef.current), fieldValues);\r\n            }\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(get(defaultValuesRef.current, fieldNames))\r\n                ? defaultValue\r\n                : get(defaultValuesRef.current, fieldNames), true);\r\n        }\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        if (Array.isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = isUndefined(watchId);\r\n        return transformToNestObject((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            combinedDefaultValues);\r\n    }, []);\r\n    function watch(fieldNames, defaultValue) {\r\n        return watchInternal(fieldNames, defaultValue);\r\n    }\r\n    function unregister(name) {\r\n        for (const fieldName of Array.isArray(name) ? name : [name]) {\r\n            removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\r\n        }\r\n    }\r\n    function registerFieldRef(ref, options = {}) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!ref.name) {\r\n                return console.warn('📋 Field is missing `name` attribute', ref, `https://react-hook-form.com/api#useForm`);\r\n            }\r\n            if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\r\n                !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\r\n                    .replace(/\\[/g, '\\\\[')\r\n                    .replace(/\\]/g, '\\\\]')).test(ref.name)) {\r\n                return console.warn('📋 `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, options);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const compareRef = (currentRef) => isWeb && (!isHTMLElement(ref) || currentRef === ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let defaultValue;\r\n        if (field &&\r\n            (isRadioOrCheckbox\r\n                ? Array.isArray(field.options) &&\r\n                    compact(field.options).find((option) => {\r\n                        return value === option.ref.value && compareRef(option.ref);\r\n                    })\r\n                : compareRef(field.ref))) {\r\n            fields[name] = Object.assign(Object.assign({}, field), options);\r\n            return;\r\n        }\r\n        if (type) {\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...compact((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                        },\r\n                    ], ref: { type, name } }, options) : Object.assign({}, fieldRefAndValidationOptions);\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\r\n        if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\r\n            defaultValue = get(isEmptyUnmountFields\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if (!isEmptyObject(options)) {\r\n            set(fieldsWithValidationRef.current, name, true);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then((error) => {\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    isEmptyObject(error)\r\n                        ? set(validFieldsRef.current, name, true)\r\n                        : unset(validFieldsRef.current, name);\r\n                    previousFormIsValid !== isEmptyObject(error) && updateFormState();\r\n                });\r\n            }\r\n        }\r\n        if (shouldUnregister && !(isFieldArray && isEmptyDefaultValue)) {\r\n            !isFieldArray && unset(formStateRef.current.dirtyFields, name);\r\n        }\r\n        if (type) {\r\n            attachEventListeners(isRadioOrCheckbox && field.options\r\n                ? field.options[field.options.length - 1]\r\n                : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\r\n        }\r\n    }\r\n    function register(refOrRegisterOptions, options) {\r\n        if (!isWindowUndefined) {\r\n            if (isString(refOrRegisterOptions)) {\r\n                registerFieldRef({ name: refOrRegisterOptions }, options);\r\n            }\r\n            else if (isObject(refOrRegisterOptions) &&\r\n                'name' in refOrRegisterOptions) {\r\n                registerFieldRef(refOrRegisterOptions, options);\r\n            }\r\n            else {\r\n                return (ref) => ref && registerFieldRef(ref, refOrRegisterOptions);\r\n            }\r\n        }\r\n    }\r\n    const handleSubmit = useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, true));\r\n        readFormStateRef.current.isSubmitting &&\r\n            updateFormState({\r\n                isSubmitting: true,\r\n            });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\r\n                formStateRef.current.errors = fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fieldsRef.current)) {\r\n                    if (field) {\r\n                        const { name } = field.ref;\r\n                        const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            unset(validFieldsRef.current, name);\r\n                        }\r\n                        else if (get(fieldsWithValidationRef.current, name)) {\r\n                            unset(formStateRef.current.errors, name);\r\n                            set(validFieldsRef.current, name, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => name in fieldsRef.current)) {\r\n                updateFormState({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitting = false;\r\n            updateFormState({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria]);\r\n    const resetRefs = ({ errors, isDirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        if (!isValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        fieldArrayDefaultValuesRef.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        updateFormState({\r\n            submitCount: submitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: isDirty ? formStateRef.current.isDirty : false,\r\n            isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: isValid ? formStateRef.current.isValid : false,\r\n            dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\r\n            touched: touched ? formStateRef.current.touched : {},\r\n            errors: errors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        fieldsRef.current = {};\r\n        defaultValuesRef.current = Object.assign({}, (values || defaultValuesRef.current));\r\n        values && renderWatchedInputs('');\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        shallowFieldsStateRef.current = shouldUnregister\r\n            ? {}\r\n            : cloneObject(values || defaultValuesRef.current);\r\n        resetRefs(omitResetState);\r\n    };\r\n    useEffect(() => {\r\n        resolver && readFormStateRef.current.isValid && validateResolver();\r\n        observerRef.current =\r\n            observerRef.current || !isWeb\r\n                ? observerRef.current\r\n                : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\r\n    }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\r\n    useEffect(() => () => {\r\n        observerRef.current && observerRef.current.disconnect();\r\n        isUnMount.current = true;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            return;\r\n        }\r\n        Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, []);\r\n    if (!resolver && readFormStateRef.current.isValid) {\r\n        formState.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n    }\r\n    const commonProps = {\r\n        trigger,\r\n        setValue: useCallback(setValue, [setInternalValue, trigger]),\r\n        getValues: useCallback(getValues, []),\r\n        register: useCallback(register, [defaultValuesRef.current]),\r\n        unregister: useCallback(unregister, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        if (prop === 'isValid' && isOnSubmit) {\r\n                            console.warn('📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\r\n                        }\r\n                    }\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = useMemo(() => (Object.assign({ isFormDirty,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        updateFormState,\r\n        removeFieldEventListener,\r\n        watchInternal, mode: modeRef.current, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnChange,\r\n        }, validateResolver: resolver ? validateResolver : undefined, fieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        useWatchFieldsRef,\r\n        useWatchRenderFunctionsRef,\r\n        fieldArrayDefaultValuesRef,\r\n        validFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        readFormStateRef,\r\n        formStateRef,\r\n        defaultValuesRef,\r\n        shallowFieldsStateRef,\r\n        fieldArrayValuesRef }, commonProps)), [\r\n        defaultValuesRef.current,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        removeFieldEventListener,\r\n        watchInternal,\r\n    ]);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: useCallback(reset, []), clearErrors: useCallback(clearErrors, []), setError: useCallback(setError, []), errors: formState.errors }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormContext = createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => useContext(FormContext);\r\nconst FormProvider = (_a) => {\r\n    var { children } = _a, props = __rest(_a, [\"children\"]);\r\n    return (createElement(FormContext.Provider, { value: Object.assign({}, props) }, children));\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value || undefined]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nvar fillBooleanArray = (value) => (Array.isArray(value) ? value : [value]).map((data) => {\r\n    if (isObject(data)) {\r\n        const object = {};\r\n        for (const key in data) {\r\n            object[key] = true;\r\n        }\r\n        return object;\r\n    }\r\n    return true;\r\n});\n\nconst mapIds = (values = [], keyName, skipWarn) => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!skipWarn) {\r\n            for (const value of values) {\r\n                if (typeof value === 'object') {\r\n                    if (keyName in value) {\r\n                        console.warn(`📋 useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`);\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    console.warn(`📋 useFieldArray input's name should be in object shape instead of flat array. https://react-hook-form.com/api#useFieldArray`);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return values.map((value) => (Object.assign({ [keyName]: value[keyName] || generateId() }, value)));\r\n};\r\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error('📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\r\n        }\r\n    }\r\n    const focusIndexRef = useRef(-1);\r\n    const isUnMount = useRef(false);\r\n    const { isFormDirty, updateWatchedValue, resetFieldArrayFunctionRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, removeFieldEventListener, formStateRef, shallowFieldsStateRef, updateFormState, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, validateResolver, getValues, shouldUnregister, fieldArrayValuesRef, } = control || methods.control;\r\n    const getDefaultValues = (values) => get(shouldUnregister ? values : shallowFieldsStateRef.current, name, []);\r\n    const fieldArrayParentName = getFieldArrayParentName(name);\r\n    const memoizedDefaultValues = useRef([\r\n        ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\r\n            ? getDefaultValues(fieldArrayDefaultValuesRef.current)\r\n            : getDefaultValues(defaultValuesRef.current)),\r\n    ]);\r\n    const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\r\n    set(fieldArrayValuesRef.current, name, fields);\r\n    const omitKey = (fields) => fields.map((_a = {}) => {\r\n        var _b = keyName, omitted = _a[_b], rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\r\n        return rest;\r\n    });\r\n    fieldArrayNamesRef.current.add(name);\r\n    const getFieldArrayValue = useCallback(() => get(fieldArrayValuesRef.current, name, []), [name]);\r\n    const getCurrentFieldsValues = () => mapIds(get(getValues(), name, getFieldArrayValue()).map((item, index) => (Object.assign(Object.assign({}, getFieldArrayValue()[index]), item))), keyName, true);\r\n    fieldArrayNamesRef.current.add(name);\r\n    if (fieldArrayParentName &&\r\n        !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\r\n        set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, cloneObject(get(defaultValuesRef.current, fieldArrayParentName)));\r\n    }\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setFields(fieldsValues);\r\n        set(fieldArrayValuesRef.current, name, fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateResolver) {\r\n            const values = getValues();\r\n            set(values, name, fieldsValues);\r\n            validateResolver(values);\r\n        }\r\n    };\r\n    const resetFields = () => {\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name)) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n                delete fieldsRef.current[key];\r\n            }\r\n        }\r\n    };\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => {\r\n        if (updatedFieldArrayValues) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n        }\r\n    };\r\n    const batchStateUpdate = (method, args, updatedFieldValues, updatedFormValues = [], shouldSet = true, shouldUpdateValid = false) => {\r\n        if (get(shallowFieldsStateRef.current, name)) {\r\n            const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(shallowFieldsStateRef.current, name, output);\r\n        }\r\n        if (get(fieldArrayDefaultValuesRef.current, name)) {\r\n            const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(formStateRef.current.touched, name)) {\r\n            const output = method(get(formStateRef.current.touched, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touched, name, output);\r\n            cleanup(formStateRef.current.touched);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFormValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (shouldUpdateValid &&\r\n            readFormStateRef.current.isValid &&\r\n            !validateResolver) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        if (!isUnMount.current && readFormStateRef.current.isDirty) {\r\n            updateFormState({\r\n                isDirty: isFormDirty(name, omitKey(updatedFormValues)),\r\n            });\r\n        }\r\n    };\r\n    const append = (value, shouldFocus = true) => {\r\n        const appendValue = Array.isArray(value) ? value : [value];\r\n        const updateFormValues = [\r\n            ...getCurrentFieldsValues(),\r\n            ...mapIds(appendValue, keyName),\r\n        ];\r\n        setFieldAndValidState(updateFormValues);\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            updateDirtyFieldsWithDefaultValues(updateFormValues);\r\n            updateFormState({\r\n                isDirty: true,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            });\r\n        }\r\n        !shouldUnregister &&\r\n            set(shallowFieldsStateRef.current, name, [\r\n                ...(get(shallowFieldsStateRef.current, name) || []),\r\n                ...cloneObject(appendValue),\r\n            ]);\r\n        focusIndexRef.current = shouldFocus\r\n            ? get(fieldArrayValuesRef.current, name).length - 1\r\n            : -1;\r\n    };\r\n    const prepend$1 = (value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(prepend, {\r\n            argA: emptyArray,\r\n            argC: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues);\r\n        focusIndexRef.current = shouldFocus ? 0 : -1;\r\n    };\r\n    const remove = (index) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldValues = removeArrayAt(fieldValues, index);\r\n        setFieldAndValidState(updatedFieldValues);\r\n        resetFields();\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n            argC: index,\r\n        }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\r\n    };\r\n    const insert$1 = (index, value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: emptyArray,\r\n            argC: index,\r\n            argD: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues, insert(fieldValues, index));\r\n        focusIndexRef.current = shouldFocus ? index : -1;\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n            argC: indexA,\r\n            argD: indexB,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n            argC: from,\r\n            argD: to,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!name) {\r\n                console.warn('📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\r\n        if (defaultValues && fields.length < defaultValues.length) {\r\n            set(fieldArrayDefaultValuesRef.current, name, defaultValues.slice(1));\r\n        }\r\n        updateWatchedValue(name);\r\n        if (focusIndexRef.current > -1) {\r\n            for (const key in fieldsRef.current) {\r\n                const field = fieldsRef.current[key];\r\n                if (key.startsWith(`${name}[${focusIndexRef.current}]`) &&\r\n                    field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        focusIndexRef.current = -1;\r\n    }, [fields, name]);\r\n    useEffect(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        if (!getFieldArrayParentName(name)) {\r\n            resetFunctions[name] = (data) => {\r\n                resetFields();\r\n                !data && unset(fieldArrayDefaultValuesRef.current, name);\r\n                unset(shallowFieldsStateRef.current, name);\r\n                memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\r\n                if (!isUnMount.current) {\r\n                    setFields(mapIds(memoizedDefaultValues.current, keyName));\r\n                }\r\n            };\r\n        }\r\n        return () => {\r\n            isUnMount.current = true;\r\n            shouldUnregister && remove();\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            unset(fieldArrayValuesRef.current, name);\r\n            fieldArrayNames.delete(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: useCallback(swap, [name]),\r\n        move: useCallback(move, [name]),\r\n        prepend: useCallback(prepend$1, [name]),\r\n        append: useCallback(append, [name]),\r\n        remove: useCallback(remove, [name]),\r\n        insert: useCallback(insert$1, [name]),\r\n        fields: compact(fields),\r\n    };\r\n};\n\nvar getInputValue = (event) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nfunction useController({ name, rules, defaultValue, control, onFocus, }) {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error('📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\r\n        }\r\n    }\r\n    const { defaultValuesRef, setValue, register, unregister, trigger, mode, reValidateMode: { isReValidateOnBlur, isReValidateOnChange }, formState, formStateRef: { current: { isSubmitted, touched, errors }, }, updateFormState, readFormStateRef, fieldsRef, fieldArrayNamesRef, shallowFieldsStateRef, } = control || methods.control;\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\r\n        ? get(shallowFieldsStateRef.current, name)\r\n        : isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue;\r\n    const [value, setInputStateValue] = useState(getInitialValue());\r\n    const valueRef = useRef(value);\r\n    const ref = useRef({\r\n        focus: () => null,\r\n    });\r\n    const onFocusRef = useRef(onFocus ||\r\n        (() => {\r\n            if (isFunction(ref.current.focus)) {\r\n                ref.current.focus();\r\n            }\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                if (!isFunction(ref.current.focus)) {\r\n                    console.warn(`📋 'ref' from Controller render prop must be attached to a React component or a DOM Element whose ref provides a 'focus()' method`);\r\n                }\r\n            }\r\n        }));\r\n    const shouldValidate = useCallback((isBlurEvent) => !skipValidation(Object.assign({ isBlurEvent,\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted, isTouched: !!get(touched, name) }, mode)), [\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted,\r\n        touched,\r\n        name,\r\n        mode,\r\n    ]);\r\n    const commonTask = useCallback(([event]) => {\r\n        const data = getInputValue(event);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    }, []);\r\n    const registerField = useCallback((shouldUpdateValue) => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!name) {\r\n                return console.warn('📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller');\r\n            }\r\n        }\r\n        if (fieldsRef.current[name]) {\r\n            fieldsRef.current[name] = Object.assign({ ref: fieldsRef.current[name].ref }, rules);\r\n        }\r\n        else {\r\n            register(Object.defineProperties({\r\n                name,\r\n                focus: onFocusRef.current,\r\n            }, {\r\n                value: {\r\n                    set(data) {\r\n                        setInputStateValue(data);\r\n                        valueRef.current = data;\r\n                    },\r\n                    get() {\r\n                        return valueRef.current;\r\n                    },\r\n                },\r\n            }), rules);\r\n            shouldUpdateValue = isUndefined(get(defaultValuesRef.current, name));\r\n        }\r\n        shouldUpdateValue &&\r\n            isNotFieldArray &&\r\n            setInputStateValue(getInitialValue());\r\n    }, [rules, name, register]);\r\n    useEffect(() => () => unregister(name), [name]);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (isUndefined(value)) {\r\n                console.warn(`📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`);\r\n            }\r\n            if (!isNotFieldArray && isUndefined(defaultValue)) {\r\n                console.warn('📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\r\n            }\r\n        }\r\n        registerField();\r\n    }, [registerField]);\r\n    useEffect(() => {\r\n        !fieldsRef.current[name] && registerField(true);\r\n    });\r\n    const onBlur = useCallback(() => {\r\n        if (readFormStateRef.current.touched && !get(touched, name)) {\r\n            set(touched, name, true);\r\n            updateFormState({\r\n                touched,\r\n            });\r\n        }\r\n        shouldValidate(true) && trigger(name);\r\n    }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);\r\n    const onChange = useCallback((...event) => setValue(name, commonTask(event), {\r\n        shouldValidate: shouldValidate(),\r\n        shouldDirty: true,\r\n    }), [setValue, name, shouldValidate]);\r\n    return {\r\n        field: {\r\n            onChange,\r\n            onBlur,\r\n            name,\r\n            value,\r\n            ref,\r\n        },\r\n        meta: Object.defineProperties({\r\n            invalid: !!get(errors, name),\r\n        }, {\r\n            isDirty: {\r\n                get() {\r\n                    return !!get(formState.dirtyFields, name);\r\n                },\r\n            },\r\n            isTouched: {\r\n                get() {\r\n                    return !!get(formState.touched, name);\r\n                },\r\n            },\r\n        }),\r\n    };\r\n}\n\nfunction useWatch({ control, name, defaultValue, }) {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error('📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\r\n        }\r\n    }\r\n    const { useWatchFieldsRef, useWatchRenderFunctionsRef, watchInternal, defaultValuesRef, } = control || methods.control;\r\n    const updateValue = useState()[1];\r\n    const idRef = useRef();\r\n    const defaultValueRef = useRef(defaultValue);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (name === '') {\r\n                console.warn('📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\r\n            }\r\n        }\r\n        const id = (idRef.current = generateId());\r\n        const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\r\n        const watchFieldsHook = useWatchFieldsRef.current;\r\n        watchFieldsHook[id] = new Set();\r\n        watchFieldsHookRender[id] = () => updateValue({});\r\n        watchInternal(name, defaultValueRef.current, id);\r\n        return () => {\r\n            delete watchFieldsHook[id];\r\n            delete watchFieldsHookRender[id];\r\n        };\r\n    }, [\r\n        name,\r\n        useWatchRenderFunctionsRef,\r\n        useWatchFieldsRef,\r\n        watchInternal,\r\n        defaultValueRef,\r\n    ]);\r\n    return idRef.current\r\n        ? watchInternal(name, defaultValueRef.current, idRef.current)\r\n        : isUndefined(defaultValue)\r\n            ? isString(name)\r\n                ? get(defaultValuesRef.current, name)\r\n                : Array.isArray(name)\r\n                    ? name.reduce((previous, inputName) => (Object.assign(Object.assign({}, previous), { [inputName]: get(defaultValuesRef.current, inputName) })), {})\r\n                    : defaultValuesRef.current\r\n            : defaultValue;\r\n}\n\nconst Controller = (props) => {\r\n    const { rules, as, render, defaultValue, control, onFocus } = props, rest = __rest(props, [\"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const { field, meta } = useController(props);\r\n    const componentProps = Object.assign(Object.assign({}, rest), field);\r\n    return as\r\n        ? isValidElement(as)\r\n            ? cloneElement(as, componentProps)\r\n            : createElement(as, componentProps)\r\n        : render\r\n            ? render(field, meta)\r\n            : null;\r\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useController, useFieldArray, useForm, useFormContext, useWatch };\n//# sourceMappingURL=index.esm.js.map\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}"]}}